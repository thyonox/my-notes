# 多线程
## 基本概念
### 线程与进程






### 优点与缺点










## 创建线程
### 继承Thread类
- **定义**
	- 继承 `java.lang.Thread` 类是 Java 中最直接的创建线程方式。Thread 类本身实现了 Runnable 接口，重写其 `run()` 方法即可定义线程行为。调用 `start()` 方法启动线程，JVM 会创建一个本地线程执行 `run()`。
- **实现步骤**
	- 创建一个类继承 Thread。
	- 重写 `run()` 方法，编写线程逻辑。
	- 创建该类的实例。
	- 调用 start() 方法启动线程（注意：直接调用 `run()` 方法不会创建新线程，仅在当前线程执行）。
- **示例**
	```java
	public class MyThread extends Thread {
	    @Override
	    public void run() {
	        for (int i = 0; i < 5; i++) {
	            System.out.println("Thread " + getName() + ": " + i);
	            try {
	                Thread.sleep(1000); // 模拟耗时操作
	            } catch (InterruptedException e) {
	                Thread.currentThread().interrupt(); // 恢复中断状态
	            }
	        }
	    }
	
	    public static void main(String[] args) {
	        MyThread thread1 = new MyThread();
	        MyThread thread2 = new MyThread();
	        thread1.start(); // 启动线程1
	        thread2.start(); // 启动线程2
	    }
	}
	```
- **优缺点**
	- **优点**：简单直观，可直接使用 Thread 的方法（如 `getName()`、`setPriority()`）。
	- **缺点**：Java 单继承限制，无法继承其他类；不利于资源共享（每个线程独立对象）。
- **适用场景**
	- 适合简单线程任务，如独立计数器或日志记录器。不推荐复杂继承结构的项目。
### 实现Runnable接口
- **定义**
	- 实现 `java.lang.Runnable` 接口是推荐的创建线程方式。该接口只有一个 `run()` 方法，线程逻辑定义在此。Runnable 实例传入 Thread 构造函数创建线程。
- **实现步骤**
	- 创建一个类实现 Runnable 接口。
	- 实现 `public void run()` 方法。
	- 创建 Runnable 实例。
	- 将其传入 Thread 构造函数创建 Thread 对象。
	- 调用 Thread 的 `start()` 启动。
- **示例**
	```java
	public class MyRunnable implements Runnable {
	    @Override
	    public void run() {
	        for (int i = 0; i < 5; i++) {
	            System.out.println("Thread " + Thread.currentThread().getName() + ": " + i);
	            try {
	                Thread.sleep(1000);
	            } catch (InterruptedException e) {
	                Thread.currentThread().interrupt();
	            }
	        }
	    }
	
	    public static void main(String[] args) {
	        Runnable runnable = new MyRunnable();
	        Thread thread1 = new Thread(runnable, "Thread-1");
	        Thread thread2 = new Thread(runnable, "Thread-2");
	        thread1.start();
	        thread2.start();
	    }
	}
	```
- **优缺点**
	- **优点**：支持多继承和接口实现，便于资源共享（多个 Thread 共享同一 Runnable 实例）；符合面向接口编程原则。
	- **缺点**：需额外创建 Thread 对象，代码稍多；无法直接返回结果。
- **适用场景**
	- 适用于需要共享数据的任务，如多个线程操作同一对象。广泛用于实际项目中，是创建线程的标准方式。
### 使用Callable和Future
- **定义**
	- `java.util.concurrent.Callable<V>` 接口类似于 Runnable，但 `call()` 方法可返回类型 V 的结果，并可抛出异常。结合 `Future<V>` 接口获取异步结果，常用于线程池。
- **实现步骤**
	- 创建类实现 Callable，实现 `V call()` 方法。
	- 使用 FutureTask 包装 Callable 实例。
	- 将 FutureTask 传入 Thread 或提交到 ExecutorService。
	- 通过 Future.get() 获取结果（阻塞等待）。
- **示例**
	```java
	import java.util.concurrent.Callable;
	import java.util.concurrent.FutureTask;
	import java.util.concurrent.ExecutionException;
	
	public class MyCallable implements Callable<Integer> {
	    @Override
	    public Integer call() throws Exception {
	        int sum = 0;
	        for (int i = 1; i <= 5; i++) {
	            sum += i;
	            Thread.sleep(1000);
	        }
	        return sum;
	    }
	
	    public static void main(String[] args) throws InterruptedException, ExecutionException {
	        Callable<Integer> callable = new MyCallable();
	        FutureTask<Integer> futureTask = new FutureTask<>(callable);
	        Thread thread = new Thread(futureTask);
	        thread.start();
	        System.out.println("Result: " + futureTask.get()); // 阻塞等待结果
	    }
	}
	```
- **优缺点**
	- 优点：支持返回值和异常抛出；易于异步编程；结合线程池高效。
	- 缺点：`get()` 阻塞主线程；需处理 InterruptedException/ExecutionException。
- **适用场景**
	- 适合需要计算结果的任务，如异步计算、数据库查询。常与 ExecutorService 结合使用。
### 使用Lambda表达式
- **定义**
	- Java 8 引入 Lambda 表达式简化 Runnable/Callable 实现，直接作为函数式接口传入 Thread 或 Executor。
- **实现步骤**
	- 使用 Lambda 定义 Runnable 或 Callable 逻辑。
	- 直接创建 Thread 或 FutureTask。
	- 启动线程或提交任务。
- **示例**
	```java
	import java.util.concurrent.*;
	
	public class LambdaThread {
	    public static void main(String[] args) throws ExecutionException, InterruptedException {
	        // Runnable Lambda
	        Thread thread = new Thread(() -> {
	            for (int i = 0; i < 5; i++) {
	                System.out.println("Lambda Thread: " + i);
	                try {
	                    Thread.sleep(1000);
	                } catch (InterruptedException e) {
	                    Thread.currentThread().interrupt();
	                }
	            }
	        });
	        thread.start();
	
	        // Callable Lambda
	        ExecutorService executor = Executors.newSingleThreadExecutor();
	        Future<Integer> future = executor.submit(() -> {
	            int sum = 0;
	            for (int i = 1; i <= 5; i++) sum += i;
	            return sum;
	        });
	        System.out.println("Lambda Result: " + future.get());
	        executor.shutdown();
	    }
	}
	```
- **优缺点**
	- **优点**：代码简洁，减少 boilerplate；易读易维护。
	- **缺点**：Lambda 限制（如无法修改外部非 final 变量），需使用 Atomic 等解决。
- **适用场景**
	- 现代 Java 项目中首选，适合简单任务或结合 Stream API 的并行处理。
### 定时器任务
- **定义**
	- 使用 `java.util.Timer` 和 `TimerTask` 实现定时/周期任务。TimerTask 实现 Runnable，`schedule()` 方法调度执行。替代方案：ScheduledExecutorService（更强大）。
- **实现步骤**
	- 创建 Timer 实例。
	- 创建 TimerTask 子类，重写 `run()`。
	- 使用 `schedule()` 或 `scheduleAtFixedRate()` 调度。
- **示例**
	```java
	import java.util.Timer;
	import java.util.TimerTask;
	
	public class TimerExample {
	    public static void main(String[] args) {
	        Timer timer = new Timer();
	        TimerTask task = new TimerTask() {
	            @Override
	            public void run() {
	                System.out.println("Timer task executed at: " + System.currentTimeMillis());
	            }
	        };
	        timer.schedule(task, 2000, 5000); // 延迟2秒，每5秒执行一次
	    }
	}
	```
- **优缺点**
	- **优点**：简单实现定时任务。
	- **缺点**：单线程执行，异常可能终止 Timer；不适合复杂调度。推荐使用 ScheduledExecutorService 替代。
- **适用场景**
	- 简单定时任务，如心跳检测。复杂场景用 Quartz 或 Spring @Scheduled。
## 线程复用









## 线程同步














## 线程通信








## 并法集合















## 高级主题







# 基本概念

- **进程和线程**：
    
    进程是一个正在运行的程序，每个进程都有独立的内存空间，是系统进行资源调度和分配的的基本单位，开销大，安全性高；线程是进程内的一个执行单元，线程共享进程的内存资源，是CPU调度和分派的基本单位，开销小、切换速度快。
    
- **并发和并行**：
    
    并发指多个线程在同**一时间段**内交替执行；并行是多个线程在**不同处理器核心**上**同时**执行。单核CPU没办法做到真正的并行，线程之间切换速度很块，给人同时执行的错觉。并发的多个任务之间是互相抢占资源的；并行的多个任务之间是不互相抢占资源的。
    
- **同步和异步**：
    
- **阻塞和非阻塞**：
    


# 线程的生命周期

Java 线程的生命周期描述了线程从创建到终止的不同状态。线程的每个状态都与线程执行过程中可能发生的行为相对应。线程状态定义在**`java.lang.Thread.state`**内部枚举类中，一共有6种，线程会在这6种状态中切换。可以通过调用 `Thread.getState()` 方法来获取线程的当前状态。

![[多线程--1.png]]

- **New（新建状态）**：当线程对象被创建时，线程处于新建状态（`New`）。此时，线程还没有开始运行，即还没有调用 `start()` 方法。
    
    ```java
    Thread thread = new Thread(new MyRunnable());
    ```
    
- **Runnable（就绪/运行状态）**：当调用 `start()` 方法后，线程进入就绪状态（`Runnable`）。此时线程已经准备好运行，等待 JVM 调度器分配 CPU 时间片。此状态包含两个子状态：
    
    - **就绪状态（Ready）**：线程处于就绪队列中，等待 CPU 的调度。
    - **运行状态（Running）**：一旦获得 CPU 时间片，线程开始执行其 `run()` 方法。
    
    ```java
    thread.start(); // 线程启动，进入Runnable状态
    ```
    
- **Blocked（阻塞状态）**：当一个线程在执行过程中需要等待某个资源时，它会进入阻塞状态（`Blocked`）。当资源可用时，线程重新进入就绪状态。线程进入阻塞状态的常见原因：
    
    - 线程尝试获取一个已经被其他线程持有的锁。
    - 线程在等待 I/O 操作完成。
    
    ```java
    synchronized(lock) {
        // 线程进入这个代码块前，会尝试获得锁
    }
    ```
    
- **Waiting（等待状态）**：线程进入等待状态（`Waiting`）时，线程将等待某个条件的发生，才会被重新唤醒并进入就绪状态。线程进入等待状态的几种常见方式：
    
    - **无条件等待**：线程调用 `Object.wait()` 方法等待某个条件的改变，直到 `notify()` 或 `notifyAll()` 被调用。
    - **等待另一个线程的执行结果**：线程调用 `Thread.join()` 方法等待另一个线程执行完毕。
    
    ```java
    synchronized(obj) {
        obj.wait(); // 线程进入等待状态
    }
    ```
    
- **Timed Waiting（计时等待状态）**：当线程调用具有时间限制的等待方法时，它会进入计时等待状态（`Timed Waiting`）。线程在指定时间后自动醒来，无需其他线程显式通知。常见的计时等待方法有：
    
    - `Thread.sleep(long millis)`：线程休眠指定的毫秒数后自动醒来。
    - `Object.wait(long timeout)`：线程等待指定时间后醒来。
    - `Thread.join(long millis)`：等待指定的线程在指定时间内完成。
    - `LockSupport.parkNanos()` 和 `LockSupport.parkUntil()`：这两个方法也会导致线程进入计时等待。
    
    ```java
    Thread.sleep(1000); // 线程进入计时等待状态，1秒后自动恢复
    ```
    
- **Terminated（终止状态）**：当线程的 `run()` 方法正常执行完毕，或者由于异常导致线程提前结束，线程将进入终止状态（`Terminated`）。一旦线程进入终止状态，它就不能再次启动。
    
    ```java
    class MyRunnable implements Runnable {
        @Override
        public void run() {
            System.out.println("Thread is running");
        }
    }
    
    public class Main {
        public static void main(String[] args) {
            Thread thread = new Thread(new MyRunnable());
            thread.start();  // 启动线程
            // 一旦run()方法执行完成，线程进入终止状态
        }
    }
    ```
    

# 线程调度

Java 中的线程调度是指 JVM 如何管理和分配线程的 CPU 资源，使得多个线程能够并发执行。在多线程编程中，线程的调度决定了线程在何时、如何被执行，调度的机制与底层操作系统紧密相关。

## 调度类型

- **时间片轮转调度（Time-Slicing Scheduling）**
    
    在时间片轮转调度中，CPU 会将可用的处理时间分成多个时间片，并轮流分配给线程。每个线程在自己的时间片内执行代码，时间片结束后，线程会释放 CPU，调度器将 CPU 分配给下一个线程。
    
    - **优点**：公平地分配 CPU 资源，每个线程都有机会运行。
    - **缺点**：如果线程数过多，每个线程分配到的时间片可能过短，导致频繁的上下文切换，影响性能。
- **抢占式调度/优先级调度（Preemptive Scheduling）**
    
    - **优点**：高优先级的线程能够快速获得 CPU 资源。
    - **缺点**：可能导致低优先级线程饥饿（即长时间得不到执行）。

## 线程调度机制

- **Java线程调度机制**：Java 中的线程调度是 **优先级调度** 和 **时间片轮转调度** 的结合。线程的执行顺序取决于线程的优先级和 CPU 的时间分配。每个 Java 线程都有一个优先级（Priority），可以通过 `Thread.setPriority(int priority)` 方法设置，优先级范围从 1 到 10：
    
    - `Thread.MIN_PRIORITY = 1`：最低优先级。
    - `Thread.NORM_PRIORITY = 5`：默认优先级。
    - `Thread.MAX_PRIORITY = 10`：最高优先级。
    
    优先级只是一个 **建议**，具体是否按照优先级调度线程取决于操作系统的实现。有些操作系统完全不理会线程优先级，而是严格采用时间片轮转调度。
    
- **操作系统线程调度机制**：Java 的线程调度依赖于操作系统的线程调度机制，因此在不同操作系统上，Java 线程的调度行为可能有所不同。常见的操作系统调度方式有：
    
    - **Windows**：使用抢占式调度和时间片轮转调度相结合的方式。线程优先级对调度有一定影响。
    - **Linux**：采用 CFS（Completely Fair Scheduler），该调度器试图公平地分配 CPU 时间片，但仍然会根据优先级进行一定的调度。
    - **MacOS**：与 Linux 类似，也使用类似的公平调度策略。
    
    操作系统在线程调度时会发生 **上下文切换**，即保存当前线程的状态（寄存器、堆栈等），并加载新调度线程的状态。这种操作会有一定的性能开销，频繁的上下文切换会导致整体系统性能下降。
    

## 线程调度方法

- `yield()` 方法
    
    `Thread.yield()`是一个静态方法，它提示线程调度器当前线程愿意让出 CPU，使其他同优先级或更高优先级的线程获得执行机会。调度器可以选择忽略这个提示。
    
    ```java
    Thread.yield();  // 当前线程放弃 CPU 控制权，允许其他线程执行
    ```
    
- `sleep()` 方法
    
    `Thread.sleep(long millis)` 使当前线程暂停指定的时间，释放 CPU 资源。与 `yield()` 不同的是，`sleep()` 强制线程暂停一段时间，无论系统调度器如何分配时间片。
    
    ```java
    Thread.sleep(1000);  // 当前线程休眠1秒钟
    ```
    
- `join()` 方法
    
    `Thread.join()` 使当前线程等待另一个线程执行完毕后再继续执行。此方法可以用于线程之间的协调，以确保某些任务在某个线程完成后再继续。
    
    ```java
    Thread t1 = new Thread(() -> {
        // 任务执行
    });
    t1.start();
    t1.join();  // 等待 t1 线程执行完毕
    System.out.println("t1 执行完成后继续");
    ```
    

## 公平性和线程饥饿

- **线程饥饿**
    
    在抢占式调度中，低优先级的线程可能会长时间得不到执行机会，这种现象称为线程饥饿（Thread Starvation）。例如，系统中的高优先级线程占用了大量 CPU 时间，导致低优先级线程一直处于等待状态。
    
- **公平调度**
    
    为了避免线程饥饿，Java 提供了一些并发工具类，如 `ReentrantLock` 和 `ThreadPoolExecutor`，这些类可以启用 **公平性** 设置，以确保线程能够按 FIFO（先入先出）的顺序获得锁或执行。使用 `ReentrantLock` 时，可以指定为公平锁（`true`），这样所有等待锁的线程会按照请求锁的顺序依次获得锁，避免优先级倒置和饥饿问题。
    
    ```java
    ReentrantLock lock = new ReentrantLock(true);  // 启用公平锁
    ```
    

## 线程池的线程调度

- **工作原理**
    
    Java 的线程池（`ExecutorService`）通过一组可重用的线程来执行任务，避免频繁创建和销毁线程的开销。线程池内部使用队列存储等待执行的任务，并根据调度策略从队列中取出任务执行。
    
- **工作队列调度**
    
    线程池使用的工作队列可以是有界的或无界的，不同的队列调度方式影响线程的执行顺序：
    
    - **FIFO 队列（`LinkedBlockingQueue`）**：任务按照先入先出顺序执行，确保公平性。
    - **优先级队列（`PriorityBlockingQueue`）**：根据任务的优先级调度线程，优先级高的任务先执行。

## 线程调度常见问题

- **优先级倒置**
    
    优先级倒置是指高优先级的线程因为低优先级的线程占用共享资源而长时间无法执行。例如，低优先级线程占用了某个锁，而高优先级线程需要等待该锁释放。在这种情况下，如果另一个中等优先级的线程不断抢占 CPU，那么高优先级线程会一直等待，导致优先级倒置。
    
- **解决方案**
    
    优先级倒置问题可以通过使用 **优先级继承**（Priority Inheritance）机制来解决。这意味着当高优先级线程等待低优先级线程持有的锁时，操作系统会暂时提高低优先级线程的优先级，直到它释放锁。
    

# 线程同步

线程同步用于解决多个线程访问共享资源时可能出现的并发问题。线程同步的目的是避免数据的不一致性和竞争条件。

## 基本概念

- **使用线程同步的目的**
    - **共享资源**：当多个线程同时读写共享资源时，如果不加以控制，可能会导致数据不一致。例如，多个线程同时修改同一个变量，可能会导致不正确的计算结果。
    - **线程安全问题**：线程安全是指多个线程并发访问某一资源时，不会因为执行顺序不同导致程序结果的不确定性或异常行为。线程同步可以确保在同一时刻只有一个线程可以访问共享资源。
- **锁：**锁是一种控制机制，用于管理对共享资源（如对象、变量、数据结构等）的并发访问。每个对象在 Java 中都有一个隐式的“锁”或“监视器”（monitor），当一个线程拥有这个对象的锁时，其他线程就无法访问被锁住的资源，必须等锁被释放后才能继续访问。
    - **加锁**：当一个线程进入某个同步代码块或同步方法时，它必须首先获得相关对象的锁。
    - **释放锁**：线程在退出同步代码块或方法时会释放锁，允许其他线程获取锁并执行。
    - **竞争条件**：如果多个线程试图同时访问一个对象的同步方法或代码块，它们会竞争锁。
- **锁住的对象**：锁住的对象就是一个线程需要在执行某段同步代码时，必须获取它的锁的那个对象。每个对象都可以被视为一把锁。
    - **实例方法的锁**：`synchronized` 实例方法锁住的是该方法所在对象 (`this`)。
    - **静态方法的锁**：`synchronized` 静态方法锁住的是整个类的 `Class` 对象。
    - **同步代码块的锁**：`synchronized` 代码块可以锁住任意对象。

## 同步方式

- **`synchronized` 关键字：**`synchronized` 是 Java 中最基本的同步机制，用于确保同一时刻只有一个线程可以访问某段代码或对象。
    
    - **同步方法：**将整个方法声明为同步，确保同一时刻只有一个线程可以执行该方法。同步方法锁定的是当前对象 (`this`)。
        
        ```java
        public synchronized void synchronizedMethod() {
            // critical section
        }
        ```
        
    - **同步代码块：**只对某段关键代码进行同步，而不是整个方法。可以对任意对象加锁，灵活控制同步的范围。其中 `lock` 是一个任意的对象，通常使用 `this` 或者一个专门的锁对象。
        
        ```java
        public void method() {
            synchronized (lock) {
                // critical section
            }
        }
        ```
        
    - **静态同步方法：**静态同步方法锁定的是该类的 `Class` 对象。
        
        ```java
        public static synchronized void staticSynchronizedMethod() {
            // critical section
        }
        ```
        
- **`ReentrantLock`类：**`ReentrantLock` 是 `java.util.concurrent.locks` 包中的锁类，提供了比 `synchronized` 更灵活的锁控制。
    
    - **可重入性**：与 `synchronized` 一样，`ReentrantLock` 也是可重入的，即同一个线程可以多次获取同一个锁。
        
        ```java
        Lock lock = new ReentrantLock();
        lock.lock();  // 获取锁
        try {
            // critical section
        } finally {
            lock.unlock();  // 确保在结束时释放锁
        }
        ```
        
    - **超时获取锁**：`tryLock()` 方法允许线程在一定时间内尝试获取锁，如果不能获得则返回 `false`。
        
        ```java
        if (lock.tryLock(1, TimeUnit.SECONDS)) {
            try {
                // critical section
            } finally {
                lock.unlock();
            }
        }
        ```
        
    - **`Lock` 的其他功能**：
        
        - `lockInterruptibly()`：获取锁时可以响应中断。
        - `newCondition()`：创建 `Condition` 对象，用于替代 `Object` 的 `wait()` 和 `notify()` 方法。

# 线程通信

- **`wait()`, `notify()`, `notifyAll()` 机制**
    
    Java 的 `Object` 类提供了 `wait()`、`notify()` 和 `notifyAll()` 方法，用于线程之间的通信。它们必须在同步块（`synchronized`）中使用，因为它们依赖于对象的监视器（监视锁）。
    
    - **`wait()`**：当前线程释放锁并进入等待状态，直到另一个线程调用 `notify()` 或 `notifyAll()`。
        - **虚假唤醒**：由于某些实现上的原因，`wait()` 可能会被错误唤醒。因此在使用 `wait()` 时，必须总是放在 `while` 循环中检查条件。
    - **`notify()`**：唤醒一个等待该对象监视器的线程。
    - **`notifyAll()`**：唤醒所有等待该对象监视器的线程。
    
    ```java
    class DataBuffer {
        private int data;
        private boolean empty = true;
    
        // 生产者方法
        public synchronized void produce(int value) throws InterruptedException {
            while (!empty) {  // 如果数据还没被消费，生产者等待
                wait();
            }
            data = value;
            empty = false;
            System.out.println("Produced: " + value);
            notify();  // 通知消费者数据已生成
        }
    
        // 消费者方法
        public synchronized int consume() throws InterruptedException {
            while (empty) {  // 如果没有数据，消费者等待
                wait();
            }
            empty = true;
            System.out.println("Consumed: " + data);
            notify();  // 通知生产者可以生产新数据
            return data;
        }
    }
    
    public class ProducerConsumerExample {
        public static void main(String[] args) {
            DataBuffer buffer = new DataBuffer();
    
            // 生产者线程
            Thread producer = new Thread(() -> {
                for (int i = 0; i < 5; i++) {
                    try {
                        buffer.produce(i);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
    
            // 消费者线程
            Thread consumer = new Thread(() -> {
                for (int i = 0; i < 5; i++) {
                    try {
                        buffer.consume();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
    
            producer.start();
            consumer.start();
        }
    }
    ```
    
- **`Condition` 和 `Lock` 机制**
    
    `Condition` 是 `Lock` 接口的一部分，提供了比 `wait()` 和 `notify()` 更加灵活的线程间通信方式。`Condition` 类似于对象监视器的等待/通知机制，但可以创建多个等待队列。可以有多个 `Condition` 实例从属于同一锁，从而实现更复杂的线程间通信。
    
    - 使用 `Lock` 替代 `synchronized`，`Condition` 替代 `wait()` 和 `notify()`。
    - `condition.await()` 类似于 `wait()`，会释放锁并进入等待队列。
    - `condition.signal()` 类似于 `notify()`，唤醒一个等待线程。
    
    ```java
    import java.util.concurrent.locks.Condition;
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;
    
    class DataBuffer {
        private int data;
        private boolean empty = true;
        private Lock lock = new ReentrantLock();
        private Condition condition = lock.newCondition();
    
        public void produce(int value) throws InterruptedException {
            lock.lock();
            try {
                while (!empty) {
                    condition.await();  // 等待消费者消费数据
                }
                data = value;
                empty = false;
                System.out.println("Produced: " + value);
                condition.signal();  // 通知消费者可以消费
            } finally {
                lock.unlock();
            }
        }
    
        public int consume() throws InterruptedException {
            lock.lock();
            try {
                while (empty) {
                    condition.await();  // 等待生产者生产数据
                }
                empty = true;
                System.out.println("Consumed: " + data);
                condition.signal();  // 通知生产者可以生产新数据
                return data;
            } finally {
                lock.unlock();
            }
        }
    }
    
    public class ProducerConsumerExample {
        public static void main(String[] args) {
            DataBuffer buffer = new DataBuffer();
    
            Thread producer = new Thread(() -> {
                for (int i = 0; i < 5; i++) {
                    try {
                        buffer.produce(i);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
    
            Thread consumer = new Thread(() -> {
                for (int i = 0; i < 5; i++) {
                    try {
                        buffer.consume();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
    
            producer.start();
            consumer.start();
        }
    }
    ```
    
- **线程通信工具类**
    
    Java `java.util.concurrent` 包提供了多个线程间通信的工具类：
    
    - **`CountDownLatch`**：允许一个或多个线程等待其他线程完成操作。可以用作等待一组线程执行完毕再继续主线程。
    - **`CyclicBarrier`**：让一组线程互相等待，直到所有线程都到达屏障（`barrier`）时，再继续执行。
    - **`Semaphore`**：用于控制同时访问资源的线程数量。
    
    ```java
    import java.util.concurrent.CountDownLatch;
    
    public class CountDownLatchExample {
        public static void main(String[] args) throws InterruptedException {
            CountDownLatch latch = new CountDownLatch(3);  // 等待3个线程完成
    
            Runnable worker = () -> {
                System.out.println(Thread.currentThread().getName() + " is working");
                latch.countDown();  // 线程完成后减少计数
            };
    
            new Thread(worker, "Worker 1").start();
            new Thread(worker, "Worker 2").start();
            new Thread(worker, "Worker 3").start();
    
            latch.await();  // 主线程等待，直到计数器变为0
            System.out.println("All workers finished. Main thread continues.");
        }
    }
    ```
    

# 线程池

Java 线程池是多线程编程中的一种常用技术，它通过复用线程来减少线程创建和销毁的开销，提高系统性能。线程池将多个任务分配给一组有限数量的线程，从而避免为每个任务都创建新线程的性能损耗。

## 创建线程池

- **通过`Executors`创建线程池**
    
    - **Fixed Thread Pool (固定大小线程池)**：使用 `newFixedThreadPool(int nThreads)` 创建一个固定大小的线程池。线程池中的线程数量是固定的。当所有线程都在执行任务时，新的任务会进入队列等待。
        
        ```java
        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
        fixedThreadPool.execute(new Task());
        fixedThreadPool.shutdown();
        ```
        
    - **Cached Thread Pool (缓存线程池)**：使用 `newCachedThreadPool()` 创建一个可以根据需要创建新线程的线程池，闲置的线程会被自动回收。适用于任务量大且不确定的场景。它会根据需要动态创建线程，闲置线程超过 60 秒会被回收。
        
        ```java
        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        cachedThreadPool.execute(new Task());
        ```
        
    - **Single Thread Executor (单线程池)**：使用 `newSingleThreadExecutor()` 创建一个只有一个线程的线程池。确保所有任务按顺序执行，适合需要串行执行任务的场景。
        
        ```java
        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
        singleThreadExecutor.execute(new Task());
        ```
        
    - **Scheduled Thread Pool (调度线程池)**：使用 `newScheduledThreadPool(int corePoolSize)` 创建一个支持定时和周期性任务的线程池。适用于需要定时或重复执行任务的场景。
        
        ```java
        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);
        scheduledThreadPool.schedule(new Task(), 5, TimeUnit.SECONDS);  // 5秒后执行
        ```
        
- **自定义线程池**
    
    - 通过 `ThreadPoolExecutor` 类可以创建自定义线程池，灵活控制线程的创建、销毁、和队列行为。
        
        ```java
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(
            2, // 核心线程数
            4, // 最大线程数
            60, // 线程存活时间
            TimeUnit.SECONDS, // 存活时间单位
            new LinkedBlockingQueue<>(100), // 任务队列
            new ThreadPoolExecutor.AbortPolicy() // 拒绝策略
        );
        ```
        

## `ExecutorService`接口

- **`execute(Runnable command)`**：提交一个 `Runnable` 任务用于执行，不返回结果。
- **`submit(Callable/Void task)`**：提交一个任务，并返回一个 `Future` 对象，通过该对象可以获取任务的执行结果。
- **`shutdown()`**：启动线程池的有序关闭，已经提交的任务会继续执行，但不接受新任务。
- **`shutdownNow()`**：立即停止线程池，并尝试中断所有正在执行的任务。
- **`awaitTermination()`**：阻塞当前线程，直到所有任务完成或超时。

## `Future` 接口

- **概念**：`Future` 表示一个任务的结果，任务可能正在进行或者已经完成。
- **常用方法**：
    - `get()`：获取任务的结果，阻塞直到任务完成。
    - `get(long timeout, TimeUnit unit)`：获取任务结果，最多等待指定时间。
    - `cancel(boolean mayInterruptIfRunning)`：取消任务。
    - `isDone()`：判断任务是否已经完成。

## 线程池核心组件

- **核心线程数 (corePoolSize)**：线程池维护的最少线程数量，即使它们处于空闲状态。
- **最大线程数 (maximumPoolSize)**：线程池允许的最大线程数量，超出该数量的任务会进入队列等待。
- **任务队列 (workQueue)**：当线程池中的所有线程都在执行任务时，新的任务会进入等待队列。
- **线程存活时间 (keepAliveTime)**：当线程池中的线程数量超过核心线程数时，空闲的非核心线程超过此时间会被回收。
- **拒绝策略 (RejectedExecutionHandler)**：当任务队列已满且线程数量达到最大值时，新的任务会根据拒绝策略处理，常用的拒绝策略包括：
    - `AbortPolicy`：直接抛出 `RejectedExecutionException`。
    - `CallerRunsPolicy`：任务由调用线程执行。
    - `DiscardPolicy`：丢弃任务，不抛出异常。
    - `DiscardOldestPolicy`：丢弃队列中最早的任务，尝试重新提交新任务。

# ThreadLocal

ThreadLocal提供了一种线程隔离机制，为每个线程保存独立的变量副本，使每个线程可以不受干扰的访问该变量。




