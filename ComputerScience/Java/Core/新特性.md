# 新特性
## Java 8新特性
### 接口的静态与默认方法

在Java8中新增了接口的静态方法与默认方法，解决了接口修改时的兼容性问题。

```java
interface MyInterface {
    default void defaultMethod() {
        System.out.println("Default method");
    }
    static void staticMethod() {
        System.out.println("Static method");
    }
}
```


### 函数式接口
函数式接口是只定义了一个抽象方法的接口，用于支持Lambda表达式。通常使用`@FunctionalInterface`注解明确接口为函数式接口。

函数式接口大多存在于`java.util.function`包中，一部分存在于其它包中。除了一些常用的函数式接口外，还有大量适用于特定数据类型的拓展接口。

常用的函数式接口有：

- `Comparator<T>` ：用于定义对象的比较规则。接受两个同类型的参数，返回一个比较结果。
    
    - `int compare(T o1, T o2)`：比较两个对象，返回负数、零或正数，分别表示第一个对象小于、等于或大于第二个对象。
        
        ```java
        Comparator<String> stringLengthComparator = (s1, s2) -> s1.length() - s2.length();
        List<String> list = Arrays.asList("apple", "banana", "pear");
        Collections.sort(list, stringLengthComparator);
        System.out.println(list);  // 按照字符串长度排序
        ```
        
- `Runnable` ：表示一个不接受参数、也不返回结果的操作，通常用于并发任务。
    
    - `void run()`：执行线程任务。
        
        ```java
        Runnable task = () -> System.out.println("Task is running");
        new Thread(task).start();
        ```
        
- `Callable<V>`
    
    - 与 `Runnable` 类似，但 `Callable` 可以返回结果，并且可以抛出异常。
        
        ```java
        Callable<Integer> task = () -> {
            return 123;
        };
        ```
        
- `Predicate<T>` ：用于对输入的值进行判断，并返回一个布尔值结果。
    
    - `boolean test(T t)`：对给定的参数进行判断，返回 `true` 或 `false`。
        
        ```java
        Predicate<Integer> isEven = x -> x % 2 == 0;
        System.out.println(isEven.test(4));  // 输出 true
        ```
        
- `Function<T, R>` ：接受一个参数，并返回一个结果。用于输入输出之间的映射关系。
    
    - `R apply(T t)`：根据输入参数返回结果。
        
        ```java
        Function<String, Integer> stringLength = s -> s.length();
        System.out.println(stringLength.apply("hello"));  // 输出 5
        ```
        
- `Consumer<T>` ：接受一个输入参数并对其进行操作，但不返回结果。常用于对某个对象执行操作。
    
    - `void accept(T t)`：对给定的参数执行操作。
        
        ```java
        Consumer<String> print = s -> System.out.println(s);
        print.accept("Hello, World!");  // 输出 Hello, World!
        ```
        
- `Supplier<T>` ：不接受任何参数，返回一个结果。通常用于工厂方法或延迟加载。
    
    - `T get()`：返回一个结果。
        
        ```java
        Supplier<Double> randomValue = () -> Math.random();
        System.out.println(randomValue.get());  // 输出一个随机数
        ```
        
- `UnaryOperator<T>` ：是 `Function<T, R>` 的特例，接受一个参数并返回同类型的结果。
    
    - `T apply(T t)`：对输入的参数进行操作并返回同类型的结果。
        
        ```java
        UnaryOperator<Integer> square = x -> x * x;
        System.out.println(square.apply(5));  // 输出 25
        ```
        
- `BiFunction<T, U, R>`：接受两个参数，并返回一个结果。
    
    - `R apply(T t, U u)`：根据两个参数返回结果。
        
        ```java
        BiFunction<String, String, Integer> compareStrings = (s1, s2) -> s1.compareTo(s2);
        System.out.println(compareStrings.apply("apple", "banana"));  // 输出负数
        ```
        
- `BinaryOperator<T>` ：是 `BiFunction<T, U, R>` 的特例，接受两个相同类型的参数并返回相同类型的结果。常用于对两个值进行组合操作。
    
    - `T apply(T t1, T t2)`：对两个参数进行操作并返回结果。
        
        ```java
        BinaryOperator<Integer> sum = (a, b) -> a + b;
        System.out.println(sum.apply(2, 3));  // 输出 5
        ```
        
- `BiPredicate<T, U>` ：接受两个参数进行判断，返回布尔值。
    
    - `boolean test(T t, U u)`：根据两个参数执行判断并返回布尔值。
        
        ```java
        BiPredicate<String, Integer> lengthGreaterThan = (s, len) -> s.length() > len;
        System.out.println(lengthGreaterThan.test("hello", 3));  // 输出 true
        ```
        
- `BiConsumer<T, U>` ：接受两个输入参数并对其进行操作，但不返回结果。
    
    - `void accept(T t, U u)`：对给定的两个参数执行操作。
        
        ```java
        BiConsumer<String, Integer> printDetails = (name, age) -> System.out.println(name + " is " + age + " years old");
        printDetails.accept("Alice", 25);  // 输出 Alice is 25 years old
        ```
        
- `ToIntFunction<T>` ：接受一个输入参数，返回 `int` 类型的结果。
    
    - `int applyAsInt(T value)`：根据输入的参数返回一个 `int` 类型的结果。
        
        ```java
        ToIntFunction<String> stringLength = s -> s.length();
        System.out.println(stringLength.applyAsInt("hello"));  // 输出 5
        ```
        




### Lambda表达式
Lambda表达式主要用于简化匿名内部类和函数式接口，允许将代码块作为参数传递，将代码块替换掉具体对象，实现更简洁的函数式编程风格。

编译器会根据**上下文推断**和**匹配目标类型**（变量声明、方法参数、返回类型**）**的方法确定该调用哪个对象的哪个方法。

Lambda表达式的代码块由三部分组成：

- **参数列表**：Lambda表达式的参数列表要与接口中抽象方法的参数列表相对应。单个参数可以不用括号，多个参数时必须使用括号括起来。
- **箭头符号**：用于分割参数列表和函数体。
- **函数体**：如果是单一语句体，Lambda会**自动返回结果**。如果是语句块，方法存在返回值时必选显式调用`return`语句。

Lambda表达式不同于匿名内部类，它不会在编译期间直接生成类文件，而是使用`invokedynamic`指令在运行时动态生成Lambda类。步骤如下：

1. 编译时，Lambda表达式并不被立即编译为具体的类文件，而是通过`invokedynamic`指令进行标记。
    
    ```java
    List<String> list = Arrays.asList("a", "b", "c");
    list.forEach(s -> System.out.println(s));
    ```
    
    ```java
    invokedynamic #1: accept()Ljava/util/function/Consumer;
    ```
    
2. 在运行时，JVM会解析`invokedynamic`指令，并通过内部的`LambdaMetafactory`工厂动态生成Lambda函数实现。
    
3. 生成的类会被JVM缓存起来，以提高后续调用的性能。
    



### 方法引用
方法引用的目的是简化Lambda表达式，直接引用类或对象方法，相当于取消了Lambda的参数列表。方法引用是Lambda表达式的语法糖，主要用于函数式编程。

具有四种形式的方法引用：

- 静态方法引用：适用于引用类中的静态方法。
    
    ```java
    // Lambda 表达式形式
    Function<Integer, String> lambda = (num) -> String.valueOf(num);
    // 方法引用形式
    Function<Integer, String> methodRef = String::valueOf;
    ```
    
- 实例方法引用（特定对象）：适用于引用某个具体对象的实例方法。方法引用是绑定到一个特定的对象上，调用时这个对象已经存在。使用**实例::实例方法**方式调用。
    
    ```java
    // 使用 Lambda 表达式
    Consumer<String> lambda = (str) -> System.out.println(str);
    // 使用方法引用
    Consumer<String> methodRef = System.out::println;
    ```
    
- 实例方法引用（任意对象）：适用于引用某个类的实例方法，该方法可以被不同的对象调用。它不是绑定到某个特定的对象上，而是可以在任意该类型的对象上调用。使用**类名::实例方法**方式调用。
    
    ```java
    // 使用 Lambda 表达式
    BiFunction<String, String, Boolean> lambda = (str1, str2) -> str1.equals(str2);
    // 使用方法引用
    BiFunction<String, String, Boolean> methodRef = String::equals;
    ```
    
- 构造方法引用：适用于引用构造方法来创建对象。
    
    ```java
    // 使用 Lambda 表达式
    Supplier<List<String>> lambda = () -> new ArrayList<>();
    // 使用方法引用
    Supplier<List<String>> methodRef = ArrayList::new;
    ```
    

匿名内部类到Lambda表达式再到方法引用的例子：

- 打印列表中的元素
    
    ```java
    import java.util.Arrays;
    import java.util.List;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
    
            // 使用匿名内部类
            names.forEach(new java.util.function.Consumer<String>() {
                @Override
                public void accept(String name) {
                    System.out.println(name);
                }
            });
        }
    }
    ```
    
    ```java
    import java.util.Arrays;
    import java.util.List;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
    
            // 使用 Lambda 表达式
            names.forEach(name -> System.out.println(name));
        }
    }
    ```
    
    ```java
    import java.util.Arrays;
    import java.util.List;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
    
            // 使用方法引用
            names.forEach(System.out::println);
        }
    }
    ```
    
- 数组排序
    
    ```java
    import java.util.Arrays;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            String[] names = {"Alice", "Bob", "Charlie"};
    
            // 使用匿名内部类
            Arrays.sort(names, new java.util.Comparator<String>() {
                @Override
                public int compare(String s1, String s2) {
                    return s1.compareToIgnoreCase(s2);
                }
            });
    
            System.out.println(Arrays.toString(names));  // 输出 [Alice, Bob, Charlie]
        }
    }
    ```
    
    ```java
    import java.util.Arrays;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            String[] names = {"Alice", "Bob", "Charlie"};
    
            // 使用 Lambda 表达式
            Arrays.sort(names, (s1, s2) -> s1.compareToIgnoreCase(s2));
    
            System.out.println(Arrays.toString(names));  // 输出 [Alice, Bob, Charlie]
        }
    }
    ```
    
    ```java
    import java.util.Arrays;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            String[] names = {"Alice", "Bob", "Charlie"};
    
            // 使用方法引用
            Arrays.sort(names, String::compareToIgnoreCase);
    
            System.out.println(Arrays.toString(names));  // 输出 [Alice, Bob, Charlie]
        }
    }
    ```
    
- 创建新对象
    
    ```java
    import java.util.ArrayList;
    import java.util.function.Supplier;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            // 使用匿名内部类
            Supplier<ArrayList<String>> supplier = new Supplier<ArrayList<String>>() {
                @Override
                public ArrayList<String> get() {
                    return new ArrayList<>();
                }
            };
    
            ArrayList<String> list = supplier.get();
            list.add("Hello");
            System.out.println(list);  // 输出 [Hello]
        }
    }
    ```
    
    ```java
    import java.util.ArrayList;
    import java.util.function.Supplier;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            // 使用 Lambda 表达式
            Supplier<ArrayList<String>> supplier = () -> new ArrayList<>();
    
            ArrayList<String> list = supplier.get();
            list.add("Hello");
            System.out.println(list);  // 输出 [Hello]
        }
    }
    ```
    
    ```java
    import java.util.ArrayList;
    import java.util.function.Supplier;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            // 使用方法引用
            Supplier<ArrayList<String>> supplier = ArrayList::new;
    
            ArrayList<String> list = supplier.get();
            list.add("Hello");
            System.out.println(list);  // 输出 [Hello]
        }
    }
    ```
    
- 求和操作
    
    ```java
    import java.util.Arrays;
    import java.util.List;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
    
            // 使用匿名内部类
            int sum = numbers.stream()
                .reduce(0, new java.util.function.BinaryOperator<Integer>() {
                    @Override
                    public Integer apply(Integer a, Integer b) {
                        return Integer.sum(a, b);
                    }
                });
    
            System.out.println(sum);  // 输出 15
        }
    }
    ```
    
    ```java
    import java.util.Arrays;
    import java.util.List;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
    
            // 使用 Lambda 表达式
            int sum = numbers.stream()
                .reduce(0, (a, b) -> Integer.sum(a, b));
    
            System.out.println(sum);  // 输出 15
        }
    }
    ```
    
    ```java
    import java.util.Arrays;
    import java.util.List;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
    
            // 使用方法引用
            int sum = numbers.stream()
                .reduce(0, Integer::sum);
    
            System.out.println(sum);  // 输出 15
        }
    }
    ```
    
- 字符串转换大写
    
    ```java
    import java.util.Arrays;
    import java.util.List;
    import java.util.stream.Collectors;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
    
            // 使用匿名内部类
            List<String> upperCaseNames = names.stream()
                .map(new java.util.function.Function<String, String>() {
                    @Override
                    public String apply(String name) {
                        return name.toUpperCase();
                    }
                })
                .collect(Collectors.toList());
    
            upperCaseNames.forEach(System.out::println);  // 输出 ALICE, BOB, CHARLIE
        }
    }
    ```
    
    ```java
    import java.util.Arrays;
    import java.util.List;
    import java.util.stream.Collectors;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
    
            // 使用 Lambda 表达式
            List<String> upperCaseNames = names.stream()
                .map(name -> name.toUpperCase())
                .collect(Collectors.toList());
    
            upperCaseNames.forEach(System.out::println);  // 输出 ALICE, BOB, CHARLIE
        }
    }
    ```
    
    ```java
    import java.util.Arrays;
    import java.util.List;
    import java.util.stream.Collectors;
    
    public class MethodReferenceExample {
        public static void main(String[] args) {
            List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
    
            // 使用方法引用
            List<String> upperCaseNames = names.stream()
                .map(String::toUpperCase)
                .collect(Collectors.toList());
    
            upperCaseNames.forEach(System.out::println);  // 输出 ALICE, BOB, CHARLIE
        }
    }
    ```
    



### StreamAPI
**Stream API** 是为了处理集合数据而引入的一套功能强大的工具，主要用于对数据源（如集合、数组）执行高效的批量操作。Stream API 提供了函数式编程风格的操作方法，通过一系列链式操作，可以对集合进行过滤、映射、排序、聚合等复杂操作。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1670906047672-8a925cdc-51a1-4f92-b9c0-5de0bd37e252.png#averageHue=%23f7f7f7&clientId=u1a4c3055-aa58-4&from=paste&height=562&id=u8de6de5c&originHeight=562&originWidth=868&originalType=binary&ratio=1&rotation=0&showTitle=false&size=70980&status=done&style=none&taskId=u01fec3d0-9939-4309-baf6-151a00c966d&title=&width=868)

- **创建Stream**
    
    - 从集合类创建：
        
        ```java
        List<String> list = Arrays.asList("a", "b", "c");
        Stream<String> stream = list.stream();
        ```
        
    - 从数组创建：
        
        ```java
        String[] arr = {"a", "b", "c"};
        Stream<String> stream = Arrays.stream(arr);
        ```
        
    - 使用 `Stream.of()` 方法：
        
        ```java
        Stream<String> stream = Stream.of("a", "b", "c");
        ```
        
- **Stream操作**
    
    **中间操作**：返回一个新的 Stream，操作是**惰性**的（即不会立即执行）。常见的中间操作有：
    
    - `filter()`：根据给定条件筛选元素（排除条件为`false`的元素）。
    - `map()`：将元素转换为其他形式。
    - `flatMap()`：将多个小的 Stream 合并为一个大 Stream。
    - `sorted()`：对元素进行排序。
    - `distinct()`：去重。
    - `limit()`：截断流，使其不超过指定的数量。
    - `skip()`：跳过指定数量的元素。
    
    **终端操作**：会触发 Stream 的实际处理，最终返回某个结果，常见的终端操作有：
    
    - `forEach()`：遍历流中的每个元素并执行操作。
    - `collect()`：将流中的元素收集到一个结果，例如 `List` 或 `Set`。
    - `toList()`：Java16引入，直接将元素收集到`List`中。
    - `reduce()`：将流中的元素组合成一个值（如求和、拼接）。
    - `count()`：返回流中的元素数量。
    - `findFirst()`：返回流中的第一个元素。
    - `anyMatch()`/`allMatch()`/`noneMatch()`：根据给定的谓词（`Predicate`）对流中的元素进行匹配检查。
- **收集器**
    
    - `Collectors.toList()`：收集流中的元素到列表。
    - `Collectors.toSet()`：收集流中的元素到集合。
    - `Collectors.joining()`：将流中的元素连接为一个字符串。
    - `Collectors.groupingBy()`：根据条件对流中的元素分组。
    - `Collectors.partitioningBy()`：根据条件对流中的元素进行二分
- **顺序流和并行流**
    
    - **顺序流 (Sequential Stream)**：操作会按顺序处理每个元素。
    - **并行流 (Parallel Stream)**：操作会并行处理元素，能够利用多核处理器提高性能。通过 `parallelStream()` 或 `parallel()` 方法可以将顺序流转换为并行流。


### Collectors
`Collectors` 是 Java 8 引入的一个工具类，位于 `java.util.stream` 包中，主要用于简化和增强流（Stream）操作中的收集过程。

- **`toList()`**
- **`toSet()`**
- **`toMap()`**
- **`joining()`**
- **`groupingBy()`**
- **`partitioningBy()`**
- **`counting()`**
- **`summarizingInt()`**
- **`reducing()`**
- **`mapping()`**


### Optional类
`Optional` 类是 Java 8 引入的一种容器类，旨在处理潜在的 `null` 值，从而减少出现 `NullPointerException` 的风险。通过 `Optional`，开发者可以显式地描述可能为空的值，并提供安全的操作方式来处理这些值。

- **创建Optional对象**
    
    - `Optional.of(T value)`：通过一个**非空**的值创建 `Optional` 对象，如果传入 `null`，则抛出 `NullPointerException`。
        
        ```java
        Optional<String> optional = Optional.of("Hello");
        ```
        
    - `Optional.ofNullable(T value)`：通过一个**可能为空**的值创建 `Optional` 对象，传入 `null` 时创建一个空的 `Optional` 对象。
        
        ```java
        Optional<String> optional = Optional.ofNullable(null); // empty Optional
        ```
        
    - `Optional.empty()`：创建一个**空的** `Optional` 对象。
        
        ```java
        Optional<String> optional = Optional.empty();
        ```
        
- **Optional操作**
    
    **判断Optional是否有值**
    
    - `isPresent()`：判断 `Optional` 是否包含非空值。如果值存在，则返回 `true`，否则返回 `false`。
    - `isEmpty()`（Java 11 引入）：判断 `Optional` 是否为空，如果为空则返回 `true`，否则返回 `false`。
    
    **获取Optional中的值**
    
    - `get()`：获取 `Optional` 中的值。如果值存在，返回该值；如果为空，则抛出 `NoSuchElementException`。因此在使用 `get()` 前需要确保 `Optional` 中有值。
        
        ```java
        String value = optional.get();
        ```
        
    - `orElse(T other)`：如果 `Optional` 中有值，返回该值；否则返回 `other`。
        
        ```java
        String value = optional.orElse("Default");
        ```
        
    - `orElseGet(Supplier<? extends T> supplier)`：类似于 `orElse`，但当 `Optional` 为空时，调用 `Supplier` 获取默认值。
        
        ```java
        String value = optional.orElseGet(() -> "Default from Supplier");
        ```
        
    - `orElseThrow()`：如果 `Optional` 中有值，返回该值；否则抛出 `NoSuchElementException`。
        
        ```java
        String value = optional.orElseThrow();
        ```
        
    - `orElseThrow(Supplier<? extends X> exceptionSupplier)`：当 `Optional` 为空时，抛出由 `Supplier` 提供的异常。
        
        ```java
        String value = optional.orElseThrow(() -> new IllegalArgumentException("No value present"));
        ```
        
    - `or(Supplier<? extends Optional<? extends T>> supplier)`：Java9引入，允许你在当前 `Optional` 为空时，提供另一个 `Optional` 作为备选方案。
        
        ```java
        public String getFirstNonNullValue(Optional<String> value1, Optional<String> value2, Optional<String> value3) {
            return value1.or(() -> value2)
                         .or(() -> value3)
                         .orElse("Default");
        }
        ```
        
    
    **操作值**
    
    - `ifPresent(Consumer<? super T> action)`：如果 `Optional` 中有值，执行提供的 `Consumer` 操作。
        
        ```java
        optional.ifPresent(value -> System.out.println("Value: " + value));
        ```
        
    - `ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`（Java 9 引入）：如果有值，执行 `action`，如果为空，则执行 `emptyAction`。
        
        ```java
        optional.ifPresentOrElse(
            value -> System.out.println("Value: " + value),
            () -> System.out.println("No value present")
        );
        ```
        
    
    **转换与过滤**
    
    - `filter(Predicate<? super T> predicate)`：对 `Optional` 中的值应用一个条件（`Predicate`），如果条件为 `true`，返回包含该值的 `Optional`；否则返回空的 `Optional`。
        
        ```java
        Optional<String> filtered = optional.filter(value -> value.startsWith("H"));
        ```
        
    - `map(Function<? super T, ? extends U> mapper)`：将 `Optional` 中的值转换为另一种类型的 `Optional`。如果 `Optional` 为空，则返回空的 `Optional`。
        
        ```java
        Optional<Integer> length = optional.map(String::length);
        ```
        
    - `flatMap(Function<? super T, Optional<U>> mapper)`：与 `map` 类似，但返回的类型必须是 `Optional`。用于避免嵌套的 `Optional<Optional<U>>` 结构。
        
        ```java
        Optional<String> optionalUpper = optional.flatMap(value -> Optional.of(value.toUpperCase()));
        ```
        
- **`map()`与`flatMap()`**
    
    `flatMap()`类似于`map()`，如果转换过程中，原始Optional容器中包含了Optional元素，`map()`会形成嵌套结构，而`flatMap()`会将Optional元素解包，不会形成嵌套。
    
    ```java
    Optional<String> optional = Optional.of("Hello");
    Optional<Optional<Integer>> nested = optional.map(s -> Optional.of(s.length())); // 返回 Optional<Optional<Integer>>
    Optional<Integer> flatMapped = optional.flatMap(s -> Optional.of(s.length())); // 返回 Optional<Integer>
    ```
    
- **Optional与Stream**
    
    `Optional` 中的值可以通过 `Stream` API 进行处理，允许更灵活地与流结合。
    
    ```java
    Optional<String> optional = Optional.of("Hello");
    optional.stream()
            .filter(s -> s.length() > 4)
            .forEach(System.out::println);
    ```
    
- **序列化**
    
    `Optional` 类并没有实现 `Serializable` 接口，因此不能直接将 `Optional` 对象序列化，处理方式通常有三种：
    
    - 避免将Optional作为字段：可以在需要时返回 `Optional`，而不是直接在类中保存 `Optional` 对象。
        
        ```java
        public class Person implements Serializable {
            private static final long serialVersionUID = 1L;
            private String name;
        
            // 不将 Optional 保存为字段
            public Optional<String> getName() {
                return Optional.ofNullable(name);
            }
        }
        ```
        
    - 自定义序列化反序列化逻辑
        
        ```java
        public class Person implements Serializable {
            private static final long serialVersionUID = 1L;
            
            // Optional 字段
            private transient Optional<String> name;
        
            public Person(Optional<String> name) {
                this.name = name;
            }
        
            // 自定义序列化逻辑
            private void writeObject(ObjectOutputStream oos) throws IOException {
                oos.defaultWriteObject();
                oos.writeObject(name.orElse(null)); // 序列化 Optional 内的值
            }
        
            // 自定义反序列化逻辑
            private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
                ois.defaultReadObject();
                String nameValue = (String) ois.readObject();
                this.name = Optional.ofNullable(nameValue); // 反序列化时重建 Optional
            }
        
            public Optional<String> getName() {
                return name;
            }
        }
        ```
        
    - 使用工具库
        
        一些第三方库，如 Jackson、Gson，可以提供对 `Optional` 的序列化支持。
        
        ```java
        ObjectMapper mapper = new ObjectMapper();
        String json = mapper.writeValueAsString(person);
        Person personDeserialized = mapper.readValue(json, Person.class);
        ```
        
- **示例**
    
    ```java
    public String getCarInsuranceName(Person person) {
        if (person != null) {
            Car car = person.getCar();
            if (car != null) {
                Insurance insurance = car.getInsurance();
                if (insurance != null) {
                    return insurance.getName();
                }
            }
        }
        return "Unknown";
    }
    ```
    
    ```java
    public String getCarInsuranceName(Optional<Person> person) {
        return person.flatMap(Person::getCar)
                     .flatMap(Car::getInsurance)
                     .map(Insurance::getName)
                     .orElse("Unknown");
    }
    ```
    




### 新的时间和日期API
Java 8 引入了全新的日期和时间 API，提供了 `java.time` 包中的类，用来替代旧的 `java.util.Date` 和 `java.util.Calendar`。这些类的设计更现代化、更易用，并且是不可变的，线程安全。

- **`LocalDate`**
    
    表示不包含时间的日期（年、月、日），通常用于处理不需要时间戳的日期场景，如生日、假期等。
    
    - `now()`：获取当前日期。
        
    - `of(year, month, day)`：根据指定的年、月、日创建日期。
        
    - `plusDays()` / `minusDays()`：在当前日期基础上加减天数。
        
    - `getYear()`, `getMonth()`, `getDayOfMonth()`：获取年、月、日。
        
    - `isBefore()` / `isAfter()`：比较日期先后
        
        ```java
        LocalDate today = LocalDate.now();
        LocalDate birthday = LocalDate.of(1990, Month.AUGUST, 10);
        LocalDate nextWeek = today.plusDays(7);
        ```
        
- **`LocalTime`**
    
    表示不包含日期的时间（时、分、秒），用于处理精确到时间的场景。
    
    - `now()`：获取当前时间。
        
    - `of(hour, minute, second)`：根据指定的时、分、秒创建时间。
        
    - `plusHours()` / `minusMinutes()`：在当前时间基础上加减时间。
        
    - `getHour()`, `getMinute()`, `getSecond()`：获取小时、分钟、秒。
        
        ```java
        LocalTime currentTime = LocalTime.now();
        LocalTime time = LocalTime.of(14, 30);
        LocalTime oneHourLater = currentTime.plusHours(1);
        ```
        
- **`LocalDateTime`**
    
    `LocalDateTime` 表示日期和时间的组合，包含年、月、日、时、分、秒，不包含时区信息。它适合需要同时处理日期和时间的场景。
    
    - `now()`：获取当前日期和时间。
        
    - `of(year, month, day, hour, minute)`：根据指定的年、月、日、时、分创建日期和时间。
        
    - `plusDays()` / `minusHours()`：加减日期或时间。
        
    - `toLocalDate()` / `toLocalTime()`：获取日期或时间部分。
        
        ```java
        LocalDateTime currentDateTime = LocalDateTime.now();
        LocalDateTime meeting = LocalDateTime.of(2023, Month.SEPTEMBER, 25, 10, 0);
        LocalDateTime tomorrow = currentDateTime.plusDays(1);
        ```
        
- **`ZonedDateTime`**
    
    `ZonedDateTime` 表示包含时区的日期和时间，适合处理跨时区的场景。它包括了日期、时间以及时区偏移量（如 `+02:00` 或 `UTC`）。
    
    - `now(ZoneId)`：获取当前指定时区的日期和时间。
        
    - `of()`：根据指定的日期、时间、时区创建 `ZonedDateTime`。
        
    - `withZoneSameInstant()`：将当前时区转换为另一个时区，同时保持时间点相同。
        
    - `getZone()`：获取时区信息。
        
        ```java
        ZonedDateTime nowInUTC = ZonedDateTime.now(ZoneOffset.UTC);
        ZonedDateTime nowInNewYork = ZonedDateTime.now(ZoneId.of("America/New_York"));
        ZonedDateTime newYorkToUTC = nowInNewYork.withZoneSameInstant(ZoneOffset.UTC);
        ```
        
- **`Instant`**
    
    `Instant` 表示时间戳，是一种从1970-01-01 00:00:00 UTC到当前时刻的秒数和纳秒数。它主要用于精确的时间戳处理。
    
    - `now()`：获取当前时间戳。
    - `ofEpochSecond()`：根据秒数创建 `Instant`。
    - `plusSeconds()` / `minusMillis()`：加减时间。
    
    ```java
    Instant timestamp = Instant.now();
    Instant tenSecondsLater = timestamp.plusSeconds(10);
    ```
    
- **`Duration` 和 `Period`**
    
    `Duration` 表示两个时间点之间的时间量，通常以秒或纳秒为单位，用于计算精确的时间差。`Period` 表示两个日期之间的年、月、日的时间量，适合处理较长的日期差。
    
    - `between(start, end)`：计算两个时间点或日期之间的差异。
        
    - `ofDays()`, `ofHours()`：创建特定时间量。
        
        ```java
        Duration duration = Duration.between(LocalTime.now(), LocalTime.of(14, 0));
        Period period = Period.between(LocalDate.now(), LocalDate.of(2024, 12, 25));
        ```
        
- **`DateTimeFormatter`**
    
    `DateTimeFormatter` 用于格式化和解析日期、时间对象。相比于 `SimpleDateFormat`，`DateTimeFormatter` 是线程安全的。
    
    - `ofPattern()`：根据指定的模式创建格式化器。
        
    - `format()`：格式化日期/时间。
        
    - `parse()`：解析字符串为日期/时间
        
        ```java
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String formattedDateTime = LocalDateTime.now().format(formatter);
        LocalDateTime parsedDateTime = LocalDateTime.parse("2024-09-23 12:00:00", formatter);
        ```
        
- **`ZoneId` 和 `ZoneOffset`**
    
    `ZoneId` 用于表示时区，`ZoneOffset` 表示与 UTC 的时区偏移量。
    
    ```java
    ZoneId zone = ZoneId.of("Asia/Shanghai");
    ZoneOffset offset = ZoneOffset.of("+08:00");
    ```
    
- **`Clock`**
    
    `Clock` 提供了访问当前日期和时间的灵活方式，可以替换系统时钟，以便于测试。
    
    ```java
    Clock clock = Clock.systemUTC();
    Instant instant = clock.instant();
    ```
    




### 并行数组排序
`Arrays.parallelSort()` 可以使用多线程对大型数组进行并行排序，提升排序性能。它在内部使用了 [Fork/Join 框架](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html)，它将数组分割成若干个小部分，分别在多个线程中并行地进行排序。排序完成后，再将各部分结果合并起来。

```java
int[] numbers = {5, 3, 1, 2, 4};
Arrays.parallelSort(numbers, 1, 4);  // 只对索引 1 到 3 的元素进行排序
System.out.println(Arrays.toString(numbers));  // 输出: [5, 1, 2, 3, 4]
```

当然也可以自定义排序，需要传入一个比较器

```java
Integer[] numbers = {1, 4, 3, 5, 2};
Arrays.parallelSort(numbers, Comparator.reverseOrder());
System.out.println(Arrays.toString(numbers));  // 输出: [5, 4, 3, 2, 1]
```

当数组的大小超过一定阈值（通常为 8192 个元素）时，并行排序表现出更明显的性能优势。否则使用 `Arrays.sort()` 可能更合适。





### 增强集合方法

- `forEach()` 方法：`forEach()` 方法是 `Iterable` 接口的默认方法，用于对集合中的每个元素执行指定的操作。它通过 `Consumer` 函数式接口来接受Lambda表达式，提供了遍历集合元素的简便方式。
    
    ```java
    List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
    names.forEach(name -> System.out.println(name));
    // 等同于
    names.forEach(System.out::println);
    ```
    
- `removeIf()` 方法：`removeIf()` 是 `Collection` 接口的新方法，用于根据指定的条件删除集合中的元素。该方法接受一个 `Predicate` 函数式接口，可以通过Lambda表达式定义删除的条件。
    
    ```java
    List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
    numbers.removeIf(n -> n % 2 == 0); // 移除所有偶数
    System.out.println(numbers); // 输出: [1, 3, 5]
    ```
    
- `replaceAll()` 方法：`replaceAll()` 是 `List` 接口中的新方法，允许根据指定的规则批量替换列表中的所有元素。它接受一个 `UnaryOperator` 函数式接口，用于定义如何转换列表中的每个元素。
    
    ```java
    List<String> names = Arrays.asList("alice", "bob", "charlie");
    names.replaceAll(String::toUpperCase); // 将所有元素转换为大写
    System.out.println(names); // 输出: [ALICE, BOB, CHARLIE]
    ```
    
- `sort()` 方法：`List` 接口中增加了 `sort()` 方法，允许使用自定义的比较器对列表进行排序。该方法可以简化传统的 `Collections.sort()` 操作，并支持Lambda表达式作为比较器。
    
    ```java
    List<String> names = Arrays.asList("Bob", "Alice", "Charlie");
    names.sort((s1, s2) -> s1.compareTo(s2)); // 使用自然顺序排序
    System.out.println(names); // 输出: [Alice, Bob, Charlie]
    ```
    
- `Spliterator` 接口：Java 8 增加了 `Spliterator` 接口（即"可分迭代器"），与 `Iterator` 类似，提供了遍历元素的功能，但它支持并行遍历，能将数据流拆分为多个部分以便并行处理。`Spliterator` 通过 `trySplit()` 方法将数据拆分，适合并行流处理。可通过 `Collection` 接口的 `spliterator()` 方法获得。
    
    ```java
    List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
    Spliterator<String> spliterator = names.spliterator();
    spliterator.forEachRemaining(System.out::println);
    ```
    
- `Map` 接口增强：Java 8 对 `Map` 接口也进行了重要的增强，新增了许多实用的方法
    
    - **`forEach()` 方法**：类似于 `Collection` 接口中的 `forEach()`，可以对 `Map` 的每个键值对执行指定的操作。
        
        ```java
        Map<String, Integer> map = new HashMap<>();
        map.put("Alice", 30);
        map.put("Bob", 25);
        map.forEach((key, value) -> System.out.println(key + ": " + value));
        ```
        
    - **`getOrDefault()` 方法**：如果指定的键存在，则返回其对应的值；否则返回一个默认值，避免了 `null` 值判断的代码。
        
        ```java
        Map<String, Integer> map = new HashMap<>();
        map.put("Alice", 30);
        int age = map.getOrDefault("Bob", 0); // Bob 不存在时返回 0
        System.out.println(age); // 输出: 0
        ```
        
    - **`putIfAbsent()` 方法**：如果 `Map` 中指定的键不存在，则将键和值添加到 `Map` 中。如果键已经存在，则不做任何修改。
        
        ```java
        Map<String, Integer> map = new HashMap<>();
        map.put("Alice", 30);
        map.putIfAbsent("Alice", 25); // "Alice" 已存在，不更新
        map.putIfAbsent("Bob", 25);   // "Bob" 不存在，插入新值
        System.out.println(map); // 输出: {Alice=30, Bob=25}
        ```
        
    - **`replace()` 方法**：用于替换指定键的值。
        
        ```java
        Map<String, Integer> map = new HashMap<>();
        map.put("Alice", 30);
        map.replace("Alice", 35); // 替换 Alice 的值为 35
        System.out.println(map); // 输出: {Alice=35}
        ```
        
    - **`replaceAll()` 方法**：对 `Map` 中的每个键值对执行指定的计算，并更新对应的值。
        
        ```java
        Map<String, Integer> map = new HashMap<>();
        map.put("Alice", 30);
        map.put("Bob", 25);
        map.replaceAll((key, value) -> value + 5); // 所有值增加 5
        System.out.println(map); // 输出: {Alice=35, Bob=30}
        ```
        
    - **`compute()` 系列方法**：
        
        - `compute()`：根据键重新计算值。
            
        - `computeIfAbsent()`：如果键不存在，则计算并插入值。
            
        - `computeIfPresent()`：如果键存在，则重新计算其值。
            
            ```java
            Map<String, Integer> map = new HashMap<>();
            map.put("Alice", 30);
            map.computeIfAbsent("Bob", key -> 25); // "Bob" 不存在，插入 25
            map.computeIfPresent("Alice", (key, value) -> value + 5); // "Alice" 存在，值增加 5
            System.out.println(map); // 输出: {Alice=35, Bob=25}
            ```
            
    - **`merge()` 方法**：用于将值合并到 `Map` 中，如果键不存在，则插入新值；如果键存在，则使用给定的函数合并值。
        
        ```java
        Map<String, Integer> map = new HashMap<>();
        map.put("Alice", 30);
        map.merge("Alice", 5, Integer::sum); // "Alice" 存在，值相加
        map.merge("Bob", 25, Integer::sum);  // "Bob" 不存在，插入 25
        System.out.println(map); // 输出: {Alice=35, Bob=25}
        ```
        




### Base64 API
Java 8 引入了 `java.util.Base64` 类，提供了对 Base64 编码和解码的支持，简化了处理 Base64 的过程。Base64 是一种常用的编码方式，主要用于将二进制数据转换为可打印字符，以便在文本环境中安全传输。

- **获取编码器**
    - `static Encoder getEncoder()`：获取默认的 Base64 编码器。
    - `static Encoder getUrlEncoder()`：获取用于 URL 编码的 Base64 编码器。适用于在 URL 中使用的 Base64 编码（使用 `-` 和 `_` 替代 `+` 和 `/`）。
    - `static Encoder getMimeEncoder()`：获取用于 MIME 编码的 Base64 编码器。用于分段编码，适合大数据块的传输。
    - `static Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)`：获取带有指定行长度和行分隔符的 MIME 编码器。
- **获取解码器**
    - `static Decoder getDecoder()`：获取默认的 Base64 解码器。
    - `static Decoder getUrlDecoder()`：获取用于 URL 解码的 Base64 解码器。
    - `static Decoder getMimeDecoder()`：获取用于 MIME 解码的 Base64 解码器。
- **编码方法**
    - `byte[] encode(byte[] src)`：将字节数组编码为 Base64 字节数组。
    - `String encodeToString(byte[] src)`：将字节数组编码为 Base64 字符串。
    - `ByteBuffer encode(ByteBuffer src)`：将字节缓冲区编码为 Base64 字节缓冲区。
    - `Encoder withoutPadding()`：返回不进行填充的 Base64 编码器。
- **解码方法**
    - `byte[] decode(byte[] src)`：将 Base64 字节数组解码为字节数组。
    - `byte[] decode(String src)`：将 Base64 字符串解码为字节数组。
    - `ByteBuffer decode(ByteBuffer src)`：将 Base64 字节缓冲区解码为字节缓冲区。
    - `ByteBuffer decode(byte[] src, int offset, int length)`：从指定的偏移量和长度解码 Base64 字节数组。
## Java 9新特性
## Java 10新特性
## Java 11新特性
## Java 17新特性
在Stream API中引入了toList()方法。
## Java 21新特性
