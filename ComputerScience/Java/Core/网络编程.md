# 网络编程
## 基本概念

## 基本网络类

Java 中的基本网络类主要包含在 `java.net` 包中，它为开发网络应用程序提供了强大的工具和 API。

- **InetAddress 类：**`InetAddress` 类表示 IP 地址，它是所有与 IP 地址相关操作的基类。它既可以表示 IPv4 地址，也可以表示 IPv6 地址。
    
    - **`getLocalHost()`**：获取本地主机的 IP 地址。
        
    - **`getByName(String host)`**：根据主机名获取主机的 `InetAddress` 对象。
        
    - **`getByAddress(byte[] addr)`**：根据 IP 地址的字节数组获取 `InetAddress` 对象。
        
    - **`getHostAddress()`**：返回 IP 地址的字符串表示形式。
        
    - **`getHostName()`**：返回与该 IP 地址关联的主机名。
        
        ```java
        import java.net.*;
        
        public class InetAddressExample {
            public static void main(String[] args) {
                try {
                    // 获取本地主机
                    InetAddress localHost = InetAddress.getLocalHost();
                    System.out.println("Local Host: " + localHost.getHostName() + " - " + localHost.getHostAddress());
        
                    // 获取远程主机
                    InetAddress google = InetAddress.getByName("www.google.com");
                    System.out.println("Google: " + google.getHostName() + " - " + google.getHostAddress());
        
                } catch (UnknownHostException e) {
                    e.printStackTrace();
                }
            }
        }
        ```
        
- **Socket类**：`Socket` 类用于实现客户端的网络通信，通过它可以连接到远程服务器，并通过输入输出流发送和接收数据。它通常用于基于 TCP 协议的网络通信。
    
    - **`Socket(String host, int port)`**：创建一个连接到指定主机和端口的 Socket。
        
    - **`getInputStream()`**：返回输入流，接收来自服务器的数据。
        
    - **`getOutputStream()`**：返回输出流，向服务器发送数据。
        
    - **`close()`**：关闭 Socket 连接。
        
        ```java
        import java.io.*;
        import java.net.*;
        
        public class SocketExample {
            public static void main(String[] args) {
                try (Socket socket = new Socket("www.google.com", 80)) {
                    OutputStream output = socket.getOutputStream();
                    PrintWriter writer = new PrintWriter(output, true);
                    writer.println("GET / HTTP/1.1");
                    writer.println("Host: www.google.com");
                    writer.println("Connection: Close");
                    writer.println();
        
                    InputStream input = socket.getInputStream();
                    BufferedReader reader = new BufferedReader(new InputStreamReader(input));
        
                    String line;
                    while ((line = reader.readLine()) != null) {
                        System.out.println(line);
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ```
        
- ServerSocket 类：`ServerSocket` 类用于服务器端，监听特定的端口，等待客户端连接。每当客户端连接时，`ServerSocket` 会返回一个新的 `Socket` 对象用于与客户端进行通信。
    
    - **`ServerSocket(int port)`**：创建一个绑定到指定端口的 `ServerSocket`。
        
    - **`accept()`**：等待并接受客户端连接，返回一个新的 `Socket` 用于与客户端通信。
        
    - **`close()`**：关闭 `ServerSocket`，停止监听。
        
        ```java
        import java.io.*;
        import java.net.*;
        
        public class ServerSocketExample {
            public static void main(String[] args) {
                try (ServerSocket serverSocket = new ServerSocket(8080)) {
                    System.out.println("Server is listening on port 8080");
        
                    // 等待客户端连接
                    Socket socket = serverSocket.accept();
                    System.out.println("Client connected");
        
                    // 获取输入输出流
                    InputStream input = socket.getInputStream();
                    BufferedReader reader = new BufferedReader(new InputStreamReader(input));
        
                    OutputStream output = socket.getOutputStream();
                    PrintWriter writer = new PrintWriter(output, true);
        
                    // 与客户端通信
                    String message = reader.readLine();
                    System.out.println("Received from client: " + message);
                    writer.println("Server response: " + message);
        
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ```
        
- DatagramSocket 类：`DatagramSocket` 类用于基于 UDP 协议的网络通信。与 `Socket` 不同，`DatagramSocket` 是无连接的，数据通过数据报（`DatagramPacket`）发送和接收。
    
    - **`DatagramSocket()`**：创建一个无特定端口绑定的 `DatagramSocket`。
        
    - **`DatagramSocket(int port)`**：创建一个绑定到特定端口的 `DatagramSocket`。
        
    - **`send(DatagramPacket p)`**：发送数据报。
        
    - **`receive(DatagramPacket p)`**：接收数据报。
        
    - **`close()`**：关闭 `DatagramSocket`。
        
        ```java
        import java.net.*;
        
        public class DatagramSocketServer {
            public static void main(String[] args) {
                try (DatagramSocket socket = new DatagramSocket(8080)) {
                    byte[] buffer = new byte[1024];
                    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
        
                    System.out.println("Server is waiting for packets...");
        
                    // 接收数据报
                    socket.receive(packet);
                    String received = new String(packet.getData(), 0, packet.getLength());
                    System.out.println("Received: " + received);
        
                    // 发送响应
                    String response = "Server response";
                    byte[] responseBytes = response.getBytes();
                    DatagramPacket responsePacket = new DatagramPacket(responseBytes, responseBytes.length, packet.getAddress(), packet.getPort());
                    socket.send(responsePacket);
        
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ```
        
        ```java
        import java.net.*;
        
        public class DatagramSocketClient {
            public static void main(String[] args) {
                try (DatagramSocket socket = new DatagramSocket()) {
                    String message = "Hello, Server!";
                    byte[] buffer = message.getBytes();
        
                    InetAddress serverAddress = InetAddress.getByName("localhost");
                    DatagramPacket packet = new DatagramPacket(buffer, buffer.length, serverAddress, 8080);
        
                    // 发送数据报
                    socket.send(packet);
        
                    // 接收服务器响应
                    byte[] responseBuffer = new byte[1024];
                    DatagramPacket responsePacket = new DatagramPacket(responseBuffer, responseBuffer.length);
                    socket.receive(responsePacket);
        
                    String response = new String(responsePacket.getData(), 0, responsePacket.getLength());
                    System.out.println("Server response: " + response);
        
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ```
        
- DatagramPacket 类：`DatagramPacket` 类表示数据报包，用于在基于 UDP 的通信中发送和接收数据。它与 `DatagramSocket` 一起使用。
    
    - **`DatagramPacket(byte[] buf, int length)`**：用于接收数据的构造方法。
    - **`DatagramPacket(byte[] buf, int length, InetAddress address, int port)`**：用于发送数据的构造方法。
    - **`getData()`**：返回数据报中的数据。
    - **`getLength()`**：返回数据报中数据的长度。
    - **`getAddress()`**：返回发送方的 IP 地址。
    - **`getPort()`**：返回发送方的端口号。
- URL类：`URL` 类表示互联网上资源的统一资源定位符（URL），它提供了一种表示 Web 资源的方式，并且可以通过 URL 连接到资源，基于HTTP通信。
    
    - **`URL(String spec)`**：通过字符串形式的 URL 创建 `URL` 对象。
        
    - **`openStream()`**：打开 URL 连接并返回输入流，读取资源内容。
        
    - **`getProtocol()`**：返回 URL 的协议（如 HTTP、HTTPS）。
        
    - **`getHost()`**：返回 URL 的主机名。
        
    - **`getPort()`**：返回 URL 的端口号。
        
        ```java
        import java.io.*;
        import java.net.*;
        
        public class URLExample {
            public static void main(String[] args) {
                try {
                    URL url = new URL("<https://www.example.com>");
                    BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
                    String inputLine;
        
                    while ((inputLine = in.readLine()) != null) {
                        System.out.println(inputLine);
                    }
                    in.close();
        
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ```
        
- URLConnection 类：`URLConnection` 类表示与 URL 之间的通信链接，提供了读取和写入数据的功能，基于HTTP通信。
    
    - **`openConnection()`**：打开 URL 连接。
        
    - **`getInputStream()`**：获取输入流，从 URL 读取数据。
        
    - **`getOutputStream()`**：获取输出流，向 URL 写入数据。
        
        ```java
        import java.io.*;
        import java.net.*;
        
        public class URLConnectionExample {
            public static void main(String[] args) {
                try {
                    URL url = new URL("<https://www.example.com>");
                    URLConnection connection = url.openConnection();
                    
                    BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                    String inputLine;
        
                    while ((inputLine = in.readLine()) != null) {
                        System.out.println(inputLine);
                    }
                    in.close();
        
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ```
        
- HttpURLConnection类：
    

## Socket编程

Java中的Socket编程是实现网络通信的重要技术之一，主要用于在客户端和服务器之间建立连接并传输数据。Java的Socket编程支持基于TCP（传输控制协议）和UDP（用户数据报协议）的通信方式，其中TCP提供可靠的数据传输，而UDP则更快速，但不保证可靠性。

### TCP的Socket编程

TCP是一种面向连接的、可靠的协议，适用于需要确保数据完整性的应用。TCP Socket通信的基本流程包括以下几个步骤：

- **服务器端**
    
    1. **创建`ServerSocket`对象**，监听特定端口，等待客户端连接。
        
    2. **接受客户端连接**，创建一个新的`Socket`用于通信。
        
    3. **通过输入输出流进行数据通信**。
        
    4. **关闭Socket**，释放资源。
        
        ```java
        import java.io.*;
        import java.net.*;
        
        public class TCPServer {
            public static void main(String[] args) {
                try (ServerSocket serverSocket = new ServerSocket(8080)) {
                    System.out.println("Server is listening on port 8080");
                    Socket socket = serverSocket.accept(); // 等待客户端连接
                    System.out.println("Client connected");
        
                    // 获取输入输出流
                    InputStream input = socket.getInputStream();
                    BufferedReader reader = new BufferedReader(new InputStreamReader(input));
        
                    OutputStream output = socket.getOutputStream();
                    PrintWriter writer = new PrintWriter(output, true);
        
                    String text;
                    while ((text = reader.readLine()) != null) {
                        System.out.println("Received from client: " + text);
                        writer.println("Server: " + text); // 回传给客户端
                    }
        
                    socket.close(); // 关闭连接
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ```
        
- **客户端**
    
    1. **创建`Socket`对象**，并连接到服务器的IP地址和端口。
        
    2. **通过输入输出流进行数据通信**。
        
    3. **关闭Socket**，释放资源。
        
        ```java
        import java.io.*;
        import java.net.*;
        
        public class TCPClient {
            public static void main(String[] args) {
                try (Socket socket = new Socket("localhost", 8080)) {
                    // 获取输入输出流
                    OutputStream output = socket.getOutputStream();
                    PrintWriter writer = new PrintWriter(output, true);
        
                    InputStream input = socket.getInputStream();
                    BufferedReader reader = new BufferedReader(new InputStreamReader(input));
        
                    // 向服务器发送消息
                    writer.println("Hello, Server!");
        
                    // 读取服务器的响应
                    String response = reader.readLine();
                    System.out.println("Server response: " + response);
                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ```
        

TCP的Socket编程中存在几个关键点：

- **阻塞模式**：`ServerSocket.accept()` 和 `Socket` 的 `InputStream.read()` 是阻塞调用，会等待连接或数据到达。
- **可靠性**：TCP 保证数据传输的顺序和完整性，适合需要精确和可靠通信的场景。
- **长连接**：Socket在不关闭的情况下可以一直保持连接，适合长时间会话。

在实际的服务器应用中，通常会有多个客户端同时请求连接。为了支持多个客户端，服务器端通常使用多线程来处理每个客户端的连接。

```java
public class MultiThreadedServer {
    public static void main(String[] args) {
        try (ServerSocket serverSocket = new ServerSocket(8080)) {
            System.out.println("Server is listening on port 8080");

            while (true) {
                Socket socket = serverSocket.accept(); // 接受客户端连接
                System.out.println("New client connected");

                // 为每个客户端创建一个新的线程
                new Thread(new ClientHandler(socket)).start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

class ClientHandler implements Runnable {
    private Socket socket;

    public ClientHandler(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try {
            InputStream input = socket.getInputStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(input));

            OutputStream output = socket.getOutputStream();
            PrintWriter writer = new PrintWriter(output, true);

            String text;
            while ((text = reader.readLine()) != null) {
                System.out.println("Received: " + text);
                writer.println("Server: " + text);
            }

            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### UDP的Socket编程

UDP 是无连接的、快速但不保证可靠性的协议。UDP的通信过程不需要建立连接，适用于对数据传输速度要求高但对可靠性要求低的场景，如实时视频或音频流。UDP Socket通信的基本流程包括以下几个步骤：

- 服务器端
    
    - **创建`DatagramSocket`**，并监听指定端口。
        
    - **接收`DatagramPacket`数据报文**。
        
    - **处理数据并可选择性发送响应报文**。
        
    - **关闭Socket**。
        
        ```java
        import java.net.*;
        
        public class UDPServer {
            public static void main(String[] args) {
                try (DatagramSocket socket = new DatagramSocket(8080)) {
                    byte[] buffer = new byte[1024];
                    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
        
                    System.out.println("Server is listening on port 8080");
        
                    while (true) {
                        // 接收数据
                        socket.receive(packet);
                        String received = new String(packet.getData(), 0, packet.getLength());
                        System.out.println("Received: " + received);
        
                        // 发送响应
                        String response = "Server: " + received;
                        byte[] responseBytes = response.getBytes();
                        DatagramPacket responsePacket = new DatagramPacket(responseBytes, responseBytes.length, packet.getAddress(), packet.getPort());
                        socket.send(responsePacket);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ```
        
- 客户端
    
    - **创建`DatagramSocket`**。
        
    - **发送`DatagramPacket`数据报文**。
        
    - **可选择性接收服务器的响应报文**。
        
    - **关闭Socket**。
        
        ```java
        import java.net.*;
        
        public class UDPClient {
            public static void main(String[] args) {
                try (DatagramSocket socket = new DatagramSocket()) {
                    String message = "Hello, Server!";
                    byte[] buffer = message.getBytes();
        
                    InetAddress serverAddress = InetAddress.getByName("localhost");
                    DatagramPacket packet = new DatagramPacket(buffer, buffer.length, serverAddress, 8080);
        
                    // 发送数据
                    socket.send(packet);
        
                    // 接收响应
                    byte[] responseBuffer = new byte[1024];
                    DatagramPacket responsePacket = new DatagramPacket(responseBuffer, responseBuffer.length);
                    socket.receive(responsePacket);
        
                    String response = new String(responsePacket.getData(), 0, responsePacket.getLength());
                    System.out.println("Server response: " + response);
        
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ```
        

UDP的Socket编程中存在几个关键点：

- **无连接**：UDP不需要建立连接即可发送和接收数据。
- **不可靠性**：数据包可能会丢失、乱序或重复，无法保证到达顺序或可靠性。
- **高效性**：相比TCP，UDP的速度更快，因为它不需要建立和维护连接，适用于对实时性要求较高的场景。

### 常见问题

- **超时设置**：可以通过`Socket.setSoTimeout(int timeout)`设置Socket的读写超时时间，避免阻塞太久。
- **数据粘包/拆包**：在TCP中，由于数据流是连续的，可能会出现一次发送的数据被拆分成多次接收，或者多次发送的数据被一次接收。可以通过自定义协议来解决这个问题，比如在每个数据包前加上长度信息。
- **异常处理**：网络通信可能会因为各种原因失败，如网络中断、连接超时等，编程时需要妥善处理这些异常。


