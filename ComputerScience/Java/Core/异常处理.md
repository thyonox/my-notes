# 异常概述
## 基本概念
- **异常定义**
	- 异常是程序运行时发生的非正常情况，可能导致程序中断或产生不可预期的结果。
	- 异常是对程序编译、运行过程中出现问题的抽象，用异常对象进行描述。
	- 在 Java 中，异常被定义为一种通过对象来表示的错误状态，这些对象是 `java.lang.Throwable` 类或其子类的实例。
	- 异常的出现通常是由于程序逻辑错误、外部资源不可用、用户输入错误或系统环境问题等原因引起的。
- **异常本质**
	- 在 Java 中，异常是一种面向对象的错误处理机制，有以下特点：
		- **对象化**：异常是 `Throwable` 类的实例，可以像普通对象一样被创建、传递和处理。
		- **层次结构**：Java 提供了丰富的异常类层次结构，方便分类和处理不同类型的错误。
		- **可控性**：通过异常处理机制（`try-catch`、`throws` 等），程序员可以捕获和处理异常，防止程序崩溃。
		- **信息携带**：异常对象通常包含错误的原因、发生位置（堆栈跟踪）等详细信息，便于调试和错误追踪。
- **异常方法**
	- 异常是 `Throwable` 及其子类的实例，共享 `Throwable` 提供的方法：
		- `getMessage()`：返回异常的详细描述信息（创建异常时传入的字符串参数）。
		- `getCause()`：返回导致此异常的底层异常（异常链）。
		- `printStackTrace()`：打印异常的堆栈跟踪信息，便于定位问题。
		- `toString()`：返回异常的简要描述。
		```java
		try {
		    throw new IOException("无法打开文件");
		} catch (IOException e) {
		    System.out.println(e.getMessage()); // 输出：无法打开文件
		    e.printStackTrace(); // 输出堆栈跟踪
		}
		```
- **异常的生命周期**
	1. **异常发生**：程序运行时遇到错误，JVM 或程序代码通过 `throw` 关键字创建并抛出异常对象。
	2. **异常传播**：异常沿调用栈向上传播，寻找匹配的 `catch` 块。
	3. **异常捕获**：在 `try-catch` 块中捕获异常，并执行相应的错误处理逻辑。
	4. **异常清理**：通过 `finally` 块或 `try-with-resources` 结构清理资源，确保程序状态一致。
	5. **异常终止或继续**：如果异常未被捕获，最终由 JVM 捕获，导致程序终止；否则，程序继续执行后续代码。
## 异常分类
- **Throwable**：异常体系的根类，所有异常都直接或间接继承自它。
	- **Error**：表示严重的、通常不可恢复的系统级错误，由 JVM 抛出，反映了运行时环境的重大问题，通常无法通过程序代码恢复。
		- 常见类型：
			- **VirtualMachineError**：与 Java 虚拟机运行相关的问题。
				- `OutOfMemoryError`：JVM 内存不足，例如分配大对象时内存耗尽。
				- `StackOverflowError`：线程调用栈溢出，通常由无限递归引起。
			- **LinkageError**：类加载或链接过程中的错误。
				- `NoClassDefFoundError`：无法找到类的定义。
				- `IncompatibleClassChangeError`：类之间的不兼容变化。
	- **Exception**：表示程序运行时可能发生的、可由程序员处理的问题，可分为：
		- **Checked Exception**（受检异常）：编译时必须处理的异常。
		- **Unchecked Exception**（非受检异常）：运行时异常，继承自 `RuntimeException`。
			- 不强制要求处理的异常，因为没有意义，比如空指针，不可能对所有指针引用进行 `try...catch`。
			- 这类异常应该时编程过程中积极避免的。
## 异常体系结构
```text
Throwable
├── Error
│   ├── VirtualMachineError
│   │   ├── OutOfMemoryError
│   │   └── StackOverflowError
│   ├── LinkageError
│   │   ├── NoClassDefFoundError
│   │   └── IncompatibleClassChangeError
│   └── InternalError
└── Exception
    ├── RuntimeException
    │   ├── NullPointerException
    │   ├── ArrayIndexOutOfBoundsException
    │   ├── IllegalArgumentException
    │   ├── ArithmeticException
    │   └── ClassCastException
    ├── IOException
    │   ├── FileNotFoundException
    │   └── EOFException
    ├── SQLException
    ├── ClassNotFoundException
    └── InterruptedException
```
# 异常处理
## 异常处理机制
- **抛出异常**
	- 定义：由程序自动或手动抛出异常，交由上层调用者进行处理。
	- 分类：
		- 自动抛出
		- 手动抛出
- **捕获异常**
	- 定义：捕获并处理异常。
## 异常处理语法
- **try…catch**
	- 定义：`try` 块包含可能抛出异常的代码，如果抛出的异常与 `catch` 块声明的类型匹配，流程就转到 `catch` 块中进行处理。
	- 语法：
		```java
		try {
		    // 可能抛出异常的代码
		} catch (ExceptionType e) {
		    // 处理异常
		}
		```
	- 示例：
		```java
		public void indexExp() {
		    int[] array = {1, 2, 3, 4, 5};
		    try {
		        for (int i = 0; i < 6; i++) {
		            System.out.println(array[i] + "");
		        }
		    } catch (IndexOutOfBoundsException e) {
		        System.out.println("IndexOutOfBoundsException");
		    }
		}
		```
	- 注意：
		- `try` 中代码可能会产生多个异常时，需要多重 `catch` 块，如果异常被某个 `catch` 块捕获，后续 `catch` 块不会执行。
		- 多重 `catch` 排列：先小后大、先子类后父类。避免底层异常被屏蔽，导致异常信息不具体。
		- `try` 块中可以嵌套 `try...catch`，内层异常有限匹配内层 `catch`。
- **try-catch-finally**
	- 定义：无论是否发生异常都将执行 `finally` 块中的代码。
	- 语法：
		```java
		try {
		    // 可能抛出异常的代码
		} catch (ExceptionType e) {
		    // 处理异常
		} finally {
		    // 无论是否发生异常都执行
		}
		```
	- 示例：
		```java
		FileReader reader = null;
		try {
		    reader = new FileReader("file.txt");
		    // 读取文件
		} catch (FileNotFoundException e) {
		    System.err.println("文件未找到: " + e.getMessage());
		} finally {
		    if (reader != null) {
		        try {
		            reader.close();
		        } catch (IOException e) {
		            System.err.println("关闭文件失败: " + e.getMessage());
		        }
		    }
		}
		```
	- 注意：
		- 如果 `catch` 块中有 `return` 语句，将直接返回，不执行 `finally` 中的代码。
		- `finally` 块中代码，常用于关闭文件、释放数据库资源等操作。
		- 当 `try` 或 `catch` 块中有 `return` 语句时，`finally` 块会在 `return` 实际生效前执行，并可能会影响最终返回值。
		- 如果 `finally` 块中包含 `return`，则以 `finally` 块的 `return` 值为准，覆盖 `try` 或 `catch` 的返回值。
		- 如果 `finally` 块中抛出新异常，方法会终止并抛出该异常，`try` 或 `catch` 的 `return` 被忽略。
- **try-with-resources**
	- 定义：自动管理声明资源，无需手动关闭资源。
	- 语法：
		```java
		try (ResourceType resource = new ResourceType()) {
		    // 使用资源
		} catch (ExceptionType e) {
		    // 处理异常
		}
		```
	- 示例：
		```java
		try (FileReader reader = new FileReader("file.txt")) {
		    int ch = reader.read();
		    System.out.println((char) ch);
		} catch (IOException e) {
		    System.err.println("文件操作失败: " + e.getMessage());
		}
		```
	- 注意：
		- 声明的资源必须实现了`java.lang.AutoCloseable`接口，这样才能自动调用接口里的 `close()` 方法关闭资源。
		- 可以声明多个资源，用分号分隔。
		- 即使 `try` 块或 `catch` 块中有 `return` 语句，资源也会在退出 `try` 块前关闭。
- **throw**
	- 定义：手动抛出异常，交由上层调用者处理。
	- 语法：
		```java
		throw new IOException("文件读取失败");
		```
	- 示例：
		```java
		if (age < 0) {
		    throw new IllegalArgumentException("年龄不能为负数");
		}
		```
	- 注意：
		- 可以自定义异常类型，常用于抛出自定义的业务异常。
- **throws**
	- 定义：在方法签名中声明可能抛出的受检异常，通知调用者处理。
	- 语法：
		```java
		public void readFile(String path) throws IOException {
		    // 方法实现
		}
		```
	- 示例：
		```java
		public void readFile(String path) throws IOException {
		    FileReader reader = new FileReader(path);
		    // 读取文件
		}
		```
	- 注意：
		- 可以抛出多个异常，使用逗号分隔。
# 自定义异常
## 作用与场景
- **作用**
	- **业务逻辑封装**：将特定业务场景的错误封装为专用的异常类，提高代码可读性和可维护性。
	- **语义化错误**：提供更具体的错误信息，便于调试和用户提示。
	- **异常层次结构**：通过继承现有异常类，融入 Java 的异常体系，方便异常分类和处理。
	- **统一异常处理**：在大型项目中，定义统一的自定义异常体系，便于集中管理错误。
- **场景**
	- **参数验证**：检查输入参数的合法性，抛出非受检异常。
	- **业务规则**：当违反业务规则时抛出异常。
	- **资源操作**：处理文件、数据库或网络操作的错误，抛出受检异常。
	- **异常转换**：将底层异常转换为更高级的业务异常。
## 创建方式
- **步骤**
	1. 创建自定义异常类，继承内置异常类。
	2. 提供有参无参构造方法。
	3. 根据需求添加自定义属性。
- **自定义受检异常**
	- 示例：
		```java
		public class CustomCheckedException extends Exception {
		    // 默认构造方法
		    public CustomCheckedException() {
		        super();
		    }
		
		    // 带错误消息的构造方法
		    public CustomCheckedException(String message) {
		        super(message);
		    }
		
		    // 带错误消息和原因的构造方法
		    public CustomCheckedException(String message, Throwable cause) {
		        super(message, cause);
		    }
		
		    // 带原因的构造方法
		    public CustomCheckedException(Throwable cause) {
		        super(cause);
		    }
		}
		```
- **自定义非受检异常**
	- 示例：
		```java
		public class CustomRuntimeException extends RuntimeException {
		    public CustomRuntimeException() {
		        super();
		    }
		
		    public CustomRuntimeException(String message) {
		        super(message);
		    }
		
		    public CustomRuntimeException(String message, Throwable cause) {
		        super(message, cause);
		    }
		
		    public CustomRuntimeException(Throwable cause) {
		        super(cause);
		    }
		}
		```
- **添加自定义属性**
	- 示例：
		```java
		public class BusinessException extends RuntimeException {
		    private final int errorCode;
		
		    public BusinessException(int errorCode, String message) {
		        super(message);
		        this.errorCode = errorCode;
		    }
		
		    public BusinessException(int errorCode, String message, Throwable cause) {
		        super(message, cause);
		        this.errorCode = errorCode;
		    }
		
		    public int getErrorCode() {
		        return errorCode;
		    }
		}
		```












