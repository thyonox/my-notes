# 常用类
## 包装类
Java中的包装类（Wrapper Classes）是用于将基本数据类型（如 `int`, `char`, `boolean` 等）封装成对象的类。Java提供了八种包装类，每种基本数据类型都有对应的包装类。

## 包装类概述

- **基本数据类型**：
    - `byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean`
- **对应的包装类**：
    - `Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Character`, `Boolean`

## 构造方法

- **基本数据类型到包装类**：
    
    ```java
    Integer intValue = new Integer(10);
    Double doubleValue = new Double(3.14);
    ```
    
- **字符串到包装类**：
    
    ```java
    Integer intFromString = new Integer("123");
    Double doubleFromString = new Double("3.14");
    ```
    

## 自动拆箱与装箱

- **自动装箱**（Autoboxing）：基本数据类型自动转换为包装类对象。
    
    ```java
    Integer intValue = 10; // 自动装箱 Integer.valueOf(10)
    ```
    
- **自动拆箱**（Unboxing）：包装类对象自动转换为基本数据类型。
    
    ```java
    int value = intValue; // 自动拆箱 intValue.intValue()
    ```
    

## 常用方法

- **获取基本数据类型的最小值和最大值**：
    
    ```java
    int minInt = Integer.MIN_VALUE;
    int maxInt = Integer.MAX_VALUE;
    ```
    
- **字符串转换为基本数据类型**：
    
    ```java
    int intValue = Integer.parseInt("123");
    double doubleValue = Double.parseDouble("3.14");
    ```
    
- **将基本数据类型转换为字符串**：
    
    ```java
    String intString = Integer.toString(123);
    String doubleString = Double.toString(3.14);
    ```
    
- **获取包装类的类型**：
    
    ```java
    Class<?> clazz = Integer.TYPE; // Integer.TYPE 返回 Class<Integer> 类型
    ```
    

## 比较

- **`equals` 方法**：用于比较包装类的值是否相等。
    
    ```java
    Integer a = new Integer(100);
    Integer b = new Integer(100);
    System.out.println(a.equals(b)); // 输出 true
    ```
    
- **`==` 运算符**：用于比较两个包装类对象的引用是否相等。
    
    ```java
    Integer a = 100;
    Integer b = 100;
    System.out.println(a == b); // 输出 true (在 -128 到 127 范围内，Java 会缓存这些值)
    ```
    

## 使用场景

- **集合框架**：Java的集合框架（如 `ArrayList`）只能存储对象而不能存储基本数据类型，因此需要使用包装类。
- **泛型**：Java泛型不能使用基本数据类型，但可以使用对应的包装类。
- **null 值支持**：包装类可以为 `null`，而基本类型不能。这使得包装类可以在需要表示“无值”或“未初始化”状态时更灵活。
- **额外功能**：包装类提供了额外的方法和功能，例如 `Integer` 类的 `parseInt` 方法，能够将字符串转换为整数。
- **序列化：**在JavaBean中，属性需要序列化和反序列化（如JSON或XML）。使用包装类可以正确地处理 `null` 值和非默认值之间的差异，而基本数据类型总是使用其默认值，可能导致错误的序列化和反序列化结果。
- **框架兼容：**许多Java框架（如Hibernate, MyBatis等）要求使用包装类而不是基本类型。
- **反射：**如果一个字段是基本类型，反射操作将无法直接操作其 `null` 值。而使用包装类可以避免这个问题，反射操作会更简单、更一致。
## String类


## StringBuffer和StringBuilder类



## Data、DataFormat、SimpleDateFormat





## Calendar类





## JDK8日期类




## Math类和Random类





## 枚举
枚举类的实例不能通过new产生，每个枚举常量都是一个枚举类的实例，枚举类中可以有属性和方法，但必须在枚举常量中实例化，也可以继承接口或类，但必须在枚举常量中实现冲重写方法。枚举常量不是一个传统意义上的常量，而是通过 public static final 修饰的枚举类的实例。相比较传统的常量，使用枚举，可以携带更多信息。
### 概念
- **定义**
	- 枚举（Enum）是 Java 5 引入的特殊类，用于定义固定数量的常量集合
	- 使用 `enum` 关键字声明，继承自 `java.lang.Enum` 类
	- 每个枚举常量是一个枚举类的 `public static final` 实例
	- 每个常量有一个从 `0` 开始的整数序数。通过 `ordinal()` 方法获取。
- **特定**
	- 类型安全：限制变量只能取特定值
	- 单例模式：枚举常量是单例的
	- 不可继承：枚举类默认 `final`，无法被继承
	- 不可实例化：无法通过 `new` 创建枚举对象
	- 线程安全：枚举常量在类加载时初始化，天然线程安全
### 语法
- **基本声明**
	- 注意：
		- 常量必须在枚举类开头声明
		- 常量之间用逗号分隔，最后一个常量后可加分号
		- 常量名通常全大写
	- 示例：
		```java
		enum Color {
		    RED, GREEN, BLUE;
		}
		```
- **带构造函数和方法**
	- 注意：
		- 枚举可以包含构造函数、字段和方法
		- 字段和方法是为了拓展枚举项的额外信息
		- 构造函数只是为了给现有的枚举项设置字段，而不能通过外部 `new` 的方式创建新的枚举项
		- 在读取枚举实例时,会自动条用枚举类的构造函数,枚举实例中的属性,相当于给构造函数传递的参数
	- 示例：
		```java
		enum Color {
		    RED(255, 0, 0),
		    GREEN(0, 255, 0),
		    BLUE(0, 0, 255);
		
		    private final int r;
		    private final int g;
		    private final int b;
		
		    Color(int r, int g, int b) {
		        this.r = r;
		        this.g = g;
		        this.b = b;
		    }
		
		    public int getR() { return r; }
		    public int getG() { return g; }
		    public int getB() { return b; }
		}
		```
### 特性
- **实现接口**
	- 枚举可以实现接口
	- 示例：
		```java
		interface Printable {
		    void print();
		}
		
		enum Color implements Printable {
		    RED {
		        public void print() {
		            System.out.println("Red color");
		        }
		    },
		    GREEN {
		        public void print() {
		            System.out.println("Green color");
		        }
		    };
		}
		```
- **抽象方法**
	- 枚举可以定义抽象方法，每个常量必须实现
	- 示例：
		```java
		enum Operation {
		    ADD {
		        public double apply(double x, double y) {
		            return x + y;
		        }
		    },
		    SUBTRACT {
		        public double apply(double x, double y) {
		            return x - y;
		        }
		    };
		
		    public abstract double apply(double x, double y);
		}
		```
- **构造函数重载**
	- 枚举可以有多个重载构造函数，但所有常量必须匹配其中一个
	- 示例：
		```java
		public enum Size {
		    SMALL("S"),
		    MEDIUM("M", 10),
		    LARGE("L", 15, true);
		
		    private final String abbreviation;
		    private final int value;
		    private final boolean isDefault;
		
		    private Size(String abbreviation) {
		        this(abbreviation, 0, false);
		    }
		
		    private Size(String abbreviation, int value) {
		        this(abbreviation, value, false);
		    }
		
		    private Size(String abbreviation, int value, boolean isDefault) {
		        this.abbreviation = abbreviation;
		        this.value = value;
		        this.isDefault = isDefault;
		    }
		
		    // Getter 方法...
		}
		```
### 方法
- **内置方法**
	- `name()`: 返回枚举常量的名称
	- `ordinal()`: 返回枚举常量的序数（从0开始）
	- `values()`: 返回枚举常量数组（隐式静态方法）
	- `valueOf(String name)`: 根据名称返回枚举常量
	- `compareTo(E o)`: 比较枚举常量序数
	- `toString()`: 默认返回常量名称，可重写
	- `equals(Object o)`: 比较枚举对象
- **自定义方法**
	- 可以添加任意实例方法或静态方法
	- 方法可以是抽象的，具体实现由每个常量提供












## BigDecimal

BigDecimal作用

《阿里巴巴 Java 开发手册》中提到：“为了避免精度丢失，可以使用 **BigDecimal** 来进行浮点数的运算”。 应用场景多在对数字精度要求极高的行业，比如金融。 浮点数的运算会有精度丢失的风险：

```java
float a = 2.0f - 1.9f;float b = 1.8f - 1.7f;System.out.println(a);// 0.100000024System.out.println(b);// 0.099999905System.out.println(a == b);// false
```

## 9.2 浮点运算精度丢失原理

如果我们现在想用浮点数表示 0.2，它的结果会是多少呢？ 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。

```java
0.2 * 2 = 0.4 -> 00.4 * 2 = 0.8 -> 00.8 * 2 = 1.6 -> 10.6 * 2 = 1.2 -> 10.2 * 2 = 0.4 -> 0（发生循环）
...
```

所以 0.2(D) = 0.00110…(B)。（D表示十进制，B表示二进制） **因为十进制的 0.2 无法精确转换成二进制小数，而计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。**

## 9.3 BigDecimal常用方法

### 创建

我们在使用 BigDecimal 时，为了防止精度丢失，推荐使用它的 BigDecimal(String val) 构造方法或者 BigDecimal.valueOf(double val) 静态方法来创建对象。 《阿里巴巴 Java 开发手册》对这部分内容也有提到，如下图所示。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1667204434975-b99b605d-9708-497e-a163-68df347295ee.png#averageHue=%23f9f8f8&clientId=u8288b6e6-784d-4&from=paste&height=244&id=u6658ebe3&originHeight=244&originWidth=907&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98938&status=done&style=none&taskId=u9434c1d0-0db3-4a0c-8ab9-7cc3822bb05&title=&width=907)

image.png

简单的来说就是通过 String 类型来创建 BigDecimal 对象。

### 加减乘除

add 方法用于将两个 BigDecimal 对象相加； subtract 方法用于将两个 BigDecimal 对象相减； multiply 方法用于将两个 BigDecimal 对象相乘； divide 方法用于将两个 BigDecimal 对象相除。 示例：

```java
BigDecimal a = new BigDecimal("1.0");BigDecimal b = new BigDecimal("0.9");System.out.println(a.add(b));// 1.9System.out.println(a.subtract(b));// 0.1System.out.println(a.multiply(b));// 0.90System.out.println(a.divide(b));// 无法除尽，抛出 ArithmeticException 异常System.out.println(a.divide(b, 2, RoundingMode.HALF_UP));// 1.11
```

这里需要注意的是，在我们使用 divide 方法的时候尽量使用 3 个参数版本，并且RoundingMode 不要选择 UNNECESSARY，否则很可能会遇到 ArithmeticException（无法除尽出现无限循环小数的时候），其中 scale 表示要保留几位小数，roundingMode 代表保留规则。 保留规则非常多，这里列举几种:

```java
public enum RoundingMode {   // 2.5 -> 3 , 1.6 -> 2   // -1.6 -> -2 , -2.5 -> -3    UP(BigDecimal.ROUND_UP),   // 2.5 -> 2 , 1.6 -> 1   // -1.6 -> -1 , -2.5 -> -2    DOWN(BigDecimal.ROUND_DOWN),   // 2.5 -> 3 , 1.6 -> 2   // -1.6 -> -1 , -2.5 -> -2    CEILING(BigDecimal.ROUND_CEILING),   // 2.5 -> 2 , 1.6 -> 1   // -1.6 -> -2 , -2.5 -> -3    FLOOR(BigDecimal.ROUND_FLOOR),   // 2.5 -> 3 , 1.6 -> 2   // -1.6 -> -2 , -2.5 -> -3    HALF_UP(BigDecimal.ROUND_HALF_UP),   //......}
```

### 大小比较

a.compareTo(b) : 返回 -1 表示 a 小于 b，0 表示 a 等于 b ， 1 表示 a 大于 b。 示例：

```java
BigDecimal a = new BigDecimal("1.0");BigDecimal b = new BigDecimal("0.9");System.out.println(a.compareTo(b));// 1
```

### 保留几位小数

通过 setScale 方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA 会提示。 示例：

```java
BigDecimal m = new BigDecimal("1.255433");BigDecimal n = m.setScale(3,RoundingMode.HALF_DOWN);System.out.println(n);// 1.255
```

## 9.4 BigDecimal等值比较

《阿里巴巴 Java 开发手册》中提到：

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1667205356349-12082e43-f39d-49d1-812b-ad024db5fd5e.png#averageHue=%23fdfcfb&clientId=u8288b6e6-784d-4&from=paste&height=86&id=u3ac951d6&originHeight=86&originWidth=828&originalType=binary&ratio=1&rotation=0&showTitle=false&size=51863&status=done&style=none&taskId=u49a3320b-9f0a-4648-8092-31c8ce36c95&title=&width=828)

image.png

BigDecimal 使用 equals() 方法进行等值比较出现问题的代码示例：

```java
BigDecimal a = new BigDecimal("1");BigDecimal b = new BigDecimal("1.0");System.out.println(a.equals(b));//false
```

这是因为 equals() 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 compareTo() 方法比较的时候会忽略精度。 1.0 的 scale 是 1，1 的 scale 是 0，因此 a.equals(b) 的结果是 false。

## 9.5 BigDecimal工具类源码

网上有一个使用人数比较多的 BigDecimal 工具类，提供了多个静态方法来简化 BigDecimal 的操作。

```java
import java.math.BigDecimal;import java.math.RoundingMode;/** * 简化BigDecimal计算的小工具类 */public class BigDecimalUtil {    /**     * 默认除法运算精度     */    private static final int DEF_DIV_SCALE = 10;    private BigDecimalUtil() {    }    /**     * 提供精确的加法运算。     *     * @param v1 被加数     * @param v2 加数     * @return 两个参数的和     */    public static double add(double v1, double v2) {        BigDecimal b1 = BigDecimal.valueOf(v1);        BigDecimal b2 = BigDecimal.valueOf(v2);        return b1.add(b2).doubleValue();    }    /**     * 提供精确的减法运算。     *     * @param v1 被减数     * @param v2 减数     * @return 两个参数的差     */    public static double subtract(double v1, double v2) {        BigDecimal b1 = BigDecimal.valueOf(v1);        BigDecimal b2 = BigDecimal.valueOf(v2);        return b1.subtract(b2).doubleValue();    }    /**     * 提供精确的乘法运算。     *     * @param v1 被乘数     * @param v2 乘数     * @return 两个参数的积     */    public static double multiply(double v1, double v2) {        BigDecimal b1 = BigDecimal.valueOf(v1);        BigDecimal b2 = BigDecimal.valueOf(v2);        return b1.multiply(b2).doubleValue();    }    /**     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到     * 小数点以后10位，以后的数字四舍五入。     *     * @param v1 被除数     * @param v2 除数     * @return 两个参数的商     */    public static double divide(double v1, double v2) {        return divide(v1, v2, DEF_DIV_SCALE);    }    /**     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指     * 定精度，以后的数字四舍五入。     *     * @param v1    被除数     * @param v2    除数     * @param scale 表示表示需要精确到小数点以后几位。     * @return 两个参数的商     */    public static double divide(double v1, double v2, int scale) {        if (scale < 0) {            throw new IllegalArgumentException(                    "The scale must be a positive integer or zero");        }        BigDecimal b1 = BigDecimal.valueOf(v1);        BigDecimal b2 = BigDecimal.valueOf(v2);        return b1.divide(b2, scale, RoundingMode.HALF_UP).doubleValue();    }    /**     * 提供精确的小数位四舍五入处理。     *     * @param v     需要四舍五入的数字     * @param scale 小数点后保留几位     * @return 四舍五入后的结果     */    public static double round(double v, int scale) {        if (scale < 0) {            throw new IllegalArgumentException(                    "The scale must be a positive integer or zero");        }        BigDecimal b = BigDecimal.valueOf(v);        BigDecimal one = new BigDecimal("1");        return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();    }    /**     * 提供精确的类型转换(Float)     *     * @param v 需要被转换的数字     * @return 返回转换结果     */    public static float convertToFloat(double v) {        BigDecimal b = new BigDecimal(v);        return b.floatValue();    }    /**     * 提供精确的类型转换(Int)不进行四舍五入     *     * @param v 需要被转换的数字     * @return 返回转换结果     */    public static int convertsToInt(double v) {        BigDecimal b = new BigDecimal(v);        return b.intValue();    }    /**     * 提供精确的类型转换(Long)     *     * @param v 需要被转换的数字     * @return 返回转换结果     */    public static long convertsToLong(double v) {        BigDecimal b = new BigDecimal(v);        return b.longValue();    }    /**     * 返回两个数中大的一个值     *     * @param v1 需要被对比的第一个数     * @param v2 需要被对比的第二个数     * @return 返回两个数中大的一个值     */    public static double returnMax(double v1, double v2) {        BigDecimal b1 = new BigDecimal(v1);        BigDecimal b2 = new BigDecimal(v2);        return b1.max(b2).doubleValue();    }    /**     * 返回两个数中小的一个值     *     * @param v1 需要被对比的第一个数     * @param v2 需要被对比的第二个数     * @return 返回两个数中小的一个值     */    public static double returnMin(double v1, double v2) {        BigDecimal b1 = new BigDecimal(v1);        BigDecimal b2 = new BigDecimal(v2);        return b1.min(b2).doubleValue();    }    /**     * 精确对比两个数字     *     * @param v1 需要被对比的第一个数     * @param v2 需要被对比的第二个数     * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1     */    public static int compareTo(double v1, double v2) {        BigDecimal b1 = BigDecimal.valueOf(v1);        BigDecimal b2 = BigDecimal.valueOf(v2);        return b1.compareTo(b2);    }}
```

## 9.6 BigDecimal底层原理

用一句话解释：十进制整数在转化成二进制数时不会有精度问题，那么把十进制小数扩大N倍让它在整数的维度上进行计算，并保留相应的精度信息。






## System类




## Scanner类




## Object




## Arrays




## Collections



## Collectors



## Element&TypeElement
在 Java 的注解处理器中，`TypeElement` 和 `Element` 是 `javax.lang.model.element` 包中的两个核心接口，表示程序结构中的各种元素。它们用于表示类、方法、字段等 Java 语言的语法元素，并帮助我们通过注解处理器访问和操作这些元素。

### 1. `Element` 接口

`Element` 是一个顶级接口，表示程序中的一个元素，它是所有具体语法元素（类、方法、字段等）的父接口。通过 `Element`，我们可以访问程序中的各种结构元素。

### 常见的 `Element` 类型

`Element` 有多种实现子类，分别表示不同的程序元素：

- **`PackageElement`**：表示一个包（package）。
- **`TypeElement`**：表示类或接口类型。
- **`ExecutableElement`**：表示方法、构造函数等可执行的元素。
- **`VariableElement`**：表示字段、枚举常量或方法参数等变量。

### `Element` 的常用方法

- **`getKind()`**：返回元素的类型，类型由 `ElementKind` 枚举类表示，如类、方法、字段等。
- **`getSimpleName()`**：返回元素的简单名称（不包含包名的名称）。
- **`getEnclosingElement()`**：返回包含该元素的上级元素。例如，一个字段的上级元素就是它所在的类。
- **`getModifiers()`**：返回元素的修饰符，如 `public`, `private`, `static` 等。
- **`asType()`**：返回元素的类型（`TypeMirror`），表示元素的 Java 类型信息。

### `Element` 示例

假设我们在处理一个类的字段，可以使用 `Element` 来获取字段的相关信息：

```java
java
Copy code
for (Element element : roundEnv.getElementsAnnotatedWith(MyAnnotation.class)) {
    if (element.getKind() == ElementKind.FIELD) {
        String fieldName = element.getSimpleName().toString();
        Set<Modifier> modifiers = element.getModifiers();
        TypeMirror fieldType = element.asType();

        // 输出字段的名称和类型
        System.out.println("Field: " + fieldName + " of type: " + fieldType);
    }
}

```

### 2. `TypeElement` 接口

`TypeElement` 是 `Element` 的一个子接口，专门用于表示类或接口。它提供了与类相关的具体信息，如类的名称、包、父类、实现的接口等。

### `TypeElement` 的常用方法

- **`getQualifiedName()`**：返回类的全限定名（包括包名），如 `com.example.MyClass`。
- **`getSimpleName()`**：返回类的简单名称，不包括包名。
- **`getEnclosingElement()`**：返回包含这个类的包（`PackageElement`）。
- **`getSuperclass()`**：返回该类的父类类型（`TypeMirror`）。
- **`getInterfaces()`**：返回该类实现的接口类型列表（`List<? extends TypeMirror>`）。
- **`getTypeParameters()`**：返回类的泛型参数（如 `List<T>` 中的 `T`）。
- **`getModifiers()`**：返回类的修饰符。

### `TypeElement` 示例

假设我们在注解处理器中想要获取某个类的信息：

```java
java
Copy code
for (Element element : roundEnv.getElementsAnnotatedWith(MyAnnotation.class)) {
    if (element.getKind() == ElementKind.CLASS) {
        TypeElement classElement = (TypeElement) element;

        // 获取类的全限定名
        String className = classElement.getQualifiedName().toString();

        // 获取类的父类
        TypeMirror superclass = classElement.getSuperclass();

        // 获取类的修饰符
        Set<Modifier> modifiers = classElement.getModifiers();

        // 输出类的全限定名和父类
        System.out.println("Class: " + className + ", Superclass: " + superclass);
    }
}

```

### 3. `Element` 与 `TypeElement` 的区别

- **`Element` 是顶级接口**：`Element` 表示所有语言元素，如类、方法、字段等。它是所有具体元素的父接口。
- **`TypeElement` 继承自 `Element`**：`TypeElement` 仅用于表示类或接口，它是 `Element` 的子接口，提供了关于类或接口的特定方法。

### 总结

- **`Element`**：表示程序中的所有元素（类、字段、方法、包等），它是一个通用的接口。
- **`TypeElement`**：是 `Element` 的子接口，专门表示类或接口，提供了更多关于类的信息（如全限定名、父类、接口等）。


## CharSequence

## 正则表达式


