
# 泛型
## 泛型概述

类型参数

### 类型擦除


# 泛型类型
## 泛型类
- **定义**：泛型类是在类定义中引入类型参数的类，允许在创建对象时指定具体类型。类型参数定义在类名后的尖括号内。
- **语法**：
	```java
	public class ClassName<T> {
	    private T field;
	    // 其他成员
	}
	```
- **示例**
	```java
	public class Box<T> {
	    private T content;
	
	    public Box(T content) {
	        this.content = content;
	    }
	
	    public void setContent(T content) {
	        this.content = content;
	    }
	
	    public T getContent() {
	        return content;
	    }
	}
	```
- **使用**：泛型类在使用时需要指定具体类型，或使用原始类型（不推荐）。Java 7 引入的菱形运算符（`<>`）简化了实例化。
	```java
	public class Main {
	    public static void main(String[] args) {
	        // 指定具体类型
	        Box<Integer> intBox = new Box<>(10);
	        Box<String> strBox = new Box<>("Hello");
	
	        // 获取值，无需类型转换
	        Integer num = intBox.getContent();
	        String str = strBox.getContent();
	
	        System.out.println(num); // 输出: 10
	        System.out.println(str); // 输出: Hello
	
	        // 使用菱形运算符
	        Box<Double> doubleBox = new Box<>(3.14); // Java 7+
	    }
	}
	```
- 注意：
	- `T` 是类型参数，代表任意类型。
	- 可以定义多个类型参数，如 `class Pair<K, V>`。
	- 泛型类在编译时提供类型安全，避免运行时 `ClassCastException`。
	- 原始类型: `Box rawBox = new Box();`（不推荐，编译器会警告，可能导致类型安全问题）。
	- 类型约束: 可以通过 `extends` 限制类型参数，如 `<T extends Number>`。
	- 不能实例化: 不能直接 `new T()`，因为类型擦除后 `T` 不可知。
## 泛型接口
- **定义**：泛型接口与泛型类类似，在接口定义中引入类型参数，允许实现类指定具体类型或保持泛型。
- **语法**：
	```java
	public interface InterfaceName<T> {
	    void method(T param);
	}
	```
- **示例**：
	```java
	public interface Printable<T> {
	    void print(T item);
	}
	```
- **使用**：
	- 指定具体类型：
		```java
		public class StringPrinter implements Printable<String> {
		    @Override
		    public void print(String item) {
		        System.out.println("Printing: " + item);
		    }
		}
		
		StringPrinter printer = new StringPrinter();
		printer.print("Hello"); // 输出: Printing: Hello
		```
	- 保持泛型：
		```java
		public class GenericPrinter<T> implements Printable<T> {
		    @Override
		    public void print(T item) {
		        System.out.println("Printing: " + item);
		    }
		}
		
		GenericPrinter<Integer> intPrinter = new GenericPrinter<>();
		intPrinter.print(42); // 输出: Printing: 42
		```
- **注意**：
	- 泛型接口常用于定义通用行为，如 `Comparable<T>`, `Comparator<T>`。
	- 复用代码，提高接口的灵活性，适用于多种类型的实现。
	- 保持泛型时，实现或继承的接口或类也需要声明泛型。
## 泛型方法
- **定义**：泛型方法是在方法声明中引入类型参数的方法，可以独立于泛型类使用。类型参数定义在方法返回类型之前。
- **语法**：
	```java
	public <T> ReturnType methodName(T param) {
	    // 方法体
	}
	```
- **示例**：
	```java
	public class Util {
	    public <T> void printArray(T[] array) {
	        for (T element : array) {
	            System.out.println(element);
	        }
	    }
	}
	```
- **使用**：
	```java
	Util util = new Util();
	Integer[] intArray = {1, 2, 3};
	String[] strArray = {"A", "B", "C"};
	
	util.printArray(intArray); // 输出: 1, 2, 3
	util.printArray(strArray); // 输出: A, B, C
	```
- **注意**：
	- `<T>` 是类型参数声明，作用范围仅限于方法。
	- 泛型方法可以是静态或非静态。
	- 类型参数可以有上界，如 `<T extends Comparable<T>>`。
	- Java 编译器通过参数类型推断 `T` 的具体类型。
	- 可以显式指定类型（不常用）: `util.<String>printArray(strArray);`
	- 泛型方法可以定义在泛型类中，方法和类的类型参数可以独立。
# 约束与通配符
## 约束
- **定义**：约束用于限制泛型中的类型参数，使其只能是某些特定类型或其子类型/超类型，从而提高代码的安全性和可控性。
- **上界约束**
	- 定义：上界约束限制类型参数必须是某个类或接口的子类型，使用 `extends` 关键字。
	- 语法：
		```java
		<T extends SuperClass>
		<T extends Interface>
		<T extends SuperClass & Interface1 & Interface2>
		```
	- 示例：
		- 单上界：
			```java
			public class NumberContainer<T extends Number> {
			    private T value;
			
			    public NumberContainer(T value) {
			        this.value = value;
			    }
			
			    public double toDouble() {
			        return value.doubleValue(); // 安全调用Number的方法
			    }
			}
			
			NumberContainer<Integer> intContainer = new NumberContainer<>(42);
			NumberContainer<Double> doubleContainer = new NumberContainer<>(3.14);
			System.out.println(intContainer.toDouble()); // 输出: 42.0
			System.out.println(doubleContainer.toDouble()); // 输出: 3.14
			// NumberContainer<String> error = new NumberContainer<>("test"); // 编译错误
			```
		- 多上界：
			```java
			public <T extends Number & Comparable<T>> T max(T a, T b) {
			    return a.compareTo(b) >= 0 ? a : b;
			}
			
			Integer maxInt = max(10, 20); // 输出: 20
			Double maxDouble = max(3.14, 2.71); // 输出: 3.14
			```
	- 注意：
		- `T` 只能是 `SuperClass` 或其子类，或者实现指定接口的类型。
		- 可以指定一个类和多个接口，但类必须放在第一个。
		- 确保类型参数具有特定方法或行为（如 `Number` 的 `doubleValue()`）。
		- 多上界常用于需要多种行为保证的场景。
		- 编译后，类型参数被替换为上界类型（如 `Number`）或 `Object`。
- **下界约束**
	- 定义：上界约束限制类型参数必须是某个类或接口的超类型，使用 `super` 关键字。
	- 语法：
		```java
		<T super LowerBound>
		```
	- 示例：
		```java
		public void addToList(List<? super Integer> list, Integer value) {
		    list.add(value); // 合法，因为list可以接受Integer及其超类型
		}
		
		List<Number> numberList = new ArrayList<>();
		List<Object> objectList = new ArrayList<>();
		addToList(numberList, 42); // 合法
		addToList(objectList, 100); // 合法
		// List<String> stringList = new ArrayList<>();
		// addToList(stringList, 42); // 编译错误
		```
	- 注意：
		- 直接在类型参数上使用 `super` 不常见，主要用于通配符场景。
		- 允许方法接受更宽泛的超类型参数。
## 通配符
- **定义**：
	- 通配符（`?`）用于表示未知类型或类型的范围，解决泛型在子类型关系中的不灵活性（如 `List<String>` 不是 `List<Object>` 的子类型）。
	- 用于在使用泛型时，设置泛型的子类型（如 `List<String>`）。
- **无界通配符**
	- 定义：表示任意类型，等价于 `<? extends Object>`。
	- 语法：
		```java
		List<?> list;
		```
	- 示例：
		```java
		public void printList(List<?> list) {
		    for (Object item : list) {
		        System.out.println(item);
		    }
		}
		
		List<String> strList = Arrays.asList("A", "B");
		List<Integer> intList = Arrays.asList(1, 2);
		printList(strList); // 输出: A, B
		printList(intList); // 输出: 1, 2
		```
	- 注意：
		- 用于只读场景，当不需要知道具体类型。
		- 常用于方法参数，表示接受任意类型的集合。
		- 不能添加元素（除 `nul` l外），因为具体类型未知。
		- 只能读取为 `Object` 类型。
- **上界通配符**
	- 定义：表示 `Type` 或其子类型，适用于“消费者”场景（只读）。
	- 语法：
		```java
		List<? extends Type>
		```
	- 示例：
		```java
		public double sum(List<? extends Number> list) {
		    double total = 0;
		    for (Number num : list) {
		        total += num.doubleValue();
		    }
		    return total;
		}
		
		List<Integer> intList = Arrays.asList(1, 2, 3);
		List<Double> doubleList = Arrays.asList(1.1, 2.2);
		System.out.println(sum(intList)); // 输出: 6.0
		System.out.println(sum(doubleList)); // 输出: 3.3
		```
	- 注意：
		- 适合从集合读取数据，类型被视为 `Type` 的子类型。
		- 保证方法可以处理 `Type` 的任何子类。
		- 不能添加元素（除 `null` 外），因为具体子类型未知。
		- 读取的元素被视为 `Type` 类型（如 `Number`）。
- **下界通配符**
	- 定义：表示 `Type` 或其超类型，适用于“生产者”场景（只写）。
	- 语法：
		```java
		List<? super Type>
		```
	- 示例：
		```java
		public void addNumbers(List<? super Integer> list) {
		    list.add(1);
		    list.add(2);
		}
		
		List<Number> numberList = new ArrayList<>();
		List<Object> objectList = new ArrayList<>();
		addNumbers(numberList); // 合法
		addNumbers(objectList); // 合法
		System.out.println(numberList); // 输出: [1, 2]
		```
	- 注意：
		- 适合向集合添加数据，允许添加 `Type` 及其子类型的元素。
		- 常用于方法参数，接受 `Type` 的超类型集合。
		- 读取元素时，只能作为 `Object` 类型，因为具体类型可能是 `Type` 的任意超类。




# 泛型的基本概念

泛型（Generics）是Java的一种特性，它允许类、接口、方法在声明时引入类型参数。类型参数是占位符，在实际使用时由具体的类型替换。泛型的目标是确保类型安全，减少强制类型转换的需要，并提高代码的可读性和可维护性。

## 泛型的特点

- **类型安全**：泛型通过在编译时检查类型一致性，防止了许多因类型不匹配而导致的运行时错误。例如，在使用泛型集合时，不再需要显式地进行类型转换，从而减少了 `ClassCastException` 的发生。
- **代码重用性**：泛型允许编写能够处理各种类型的通用算法和数据结构，而不必为每种类型单独编写重复的代码。
- **编译时类型检查**：编译器在编译时检查代码的类型安全性，这有助于提前发现错误。

## 泛型的基本语法

泛型通过使用类型参数来定义，类型参数使用尖括号 `<>` 括起来。例如，`<T>` 就是一个类型参数，其中 `T` 可以是任何对象类型。

```java
public class GenericClass<T> {
    private T value;

    public GenericClass(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}
```

## 类型参数命名

- `T`：表示类型（Type）
- `E`：表示集合中的元素（Element）
- `K`、`V`：表示键值对中的键（Key）和值（Value）
- `N`：表示数字（Number）
- 这些命名惯例是为了提高代码的可读性，但并不是强制要求。

# 泛型的特性

## 通配符

Java中的通配符（Wildcard）是泛型中的一个重要概念，用于增强泛型代码的灵活性。通配符允许定义可以接收多种类型的泛型类型，适用于一些方法和类操作需要处理不同类型的数据的情况。主要适用于调用泛型时对类型参数的细化。

Java提供了三种主要类型的通配符：

1. **无界通配符（Unbounded Wildcard）：`?`**
2. **上界通配符（Upper Bounded Wildcard）：`? extends T`**
3. **下界通配符（Lower Bounded Wildcard）：`? super T`**

### 无界通配符

无界通配符 `?` 表示未知类型。它通常用于你不关心通配符的实际类型、只需要使用对象的一些常规方法（如 `toString()`、`equals()`）的情况。

无界通配符常用于以下情况：

- 当你想操作一组对象，但不需要使用它们的具体类型时。
- 作为泛型方法的参数类型，表示可以接受任何类型的泛型集合。

```java
public static void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}

List<String> stringList = List.of("Apple", "Banana", "Cherry");
printList(stringList); // 可以传入任意类型的List，例如List<String>、List<Integer>等
```

无界通配符与类型参数的区别：

- **使用无界通配符 `?`**：当你不关心参数的具体类型，只需要对泛型对象进行操作（如打印、检查大小等）。
- **使用类型参数 `T`**：当你编写的方法或类需要知道泛型类型的具体类型，或者你需要在方法或类的定义中多次使用该类型。
- **只用于读操作**：在方法或类中使用无界通配符时，通常只能读取而不能写入，因为写入需要具体的类型信息。
- **代码比较：**
    - 无界通配符：
        
        ```java
        public static void printFirst(List<?> list) {
            if (!list.isEmpty()) {
                System.out.println(list.get(0));
            }
        }
        ```
        
    - 类型参数：
        
        ```java
        public static <T> T getFirst(List<T> list) {
            return list.isEmpty() ? null : list.get(0);
        }
        
        ```
        

### 上界通配符

上界通配符 `? extends T` 表示类型必须是 `T` 或 `T` 的子类（即可以用 `T` 类型或 `T` 类型的子类替代 `?`）。它用于只读操作，因为你只能从中读取数据，而不能将数据写入其中。利用上界通配符可以让泛型具有协变性，即：要求传入`List<Animal>`的参数可以传入`List<Dog>`。

上界通配符常用于以下情况：

- 你需要从泛型对象中获取数据，而不向其中写入数据。
- 例如，在一个方法中读取一组 `Number` 或其子类（如 `Integer`、`Double`）的元素。

```java
public static void printNumbers(List<? extends Number> numbers) {
    for (Number number : numbers) {
        System.out.println(number);
    }
}

List<Integer> intList = List.of(1, 2, 3);
List<Double> doubleList = List.of(1.1, 2.2, 3.3);

printNumbers(intList);     // 可以传入 List<Integer>
printNumbers(doubleList);  // 可以传入 List<Double>
```

只读操作的原因：

- 当使用 `? extends Number` 时，编译器并不知道参数的具体类型，如果方法传入的是`Double`类型，但在方法中写入了`Integer`类型，就会导致错误。

### 下界通配符

下界通配符 `? super T` 表示类型必须是 `T` 或 `T` 的父类（即可以用 `T` 类型或 `T` 类型的父类替代 `?`）。它用于写入操作，因为你可以向泛型对象中写入数据，但不能从中读取数据为具体的类型（只能读取为 `Object` 类型）。利用下界通配符可以让泛型具有逆变性，即：要求传入`List<Dog>`的参数可以传入`List<Animal>`。

下界通配符常用于以下情况：

- 你需要向泛型对象中写入数据，而不从中读取数据。
- 例如，在一个方法中向一个 `List` 中添加 `Integer` 类型的数据。

```java
public static void addIntegers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
    list.add(3);
}

List<Number> numList = new ArrayList<>();
addIntegers(numList); // 可以传入 List<Number>
```

### 使用限制

- **不能使用通配符来创建对象实例**：例如，`new ArrayList<?>();` 是非法的，因为通配符代表一个未知类型，无法实例化。
- **不能使用通配符作为泛型类或泛型方法的类型参数**：例如，`class MyClass<?>` 或 `public <?> void doSomething()` 是非法的。
- **不能使用通配符来调用类型为未知的泛型方法**：例如，不能写 `list.add(?)`，因为通配符 `?` 没有实际的类型信息。

### 协变与逆变

- **协变（Covariance）**：使用 `? extends T` 表示，它使得泛型类能够接受某个类或其子类的对象。
- **逆变（Contravariance）**：使用 `? super T` 表示，它使得泛型类能够接受某个类或其父类的对象。

### 与类型参数的比较

- **类型参数**：定义泛型时使用，代表一种未知的具体类型。
- **通配符**：使用泛型时使用，表示一种未知类型，用于增加方法或类的灵活性。

## 受限类型参数

泛型的受限类型参数（Bounded Type Parameters）允许你对泛型类型参数设置约束，以限制它们可以接受的类型范围。这种机制提高了泛型代码的灵活性和类型安全性。主要有两种类型的限制：上界限制和多重上界限制。

### 上界限制

使用 `extends` 关键字来指定类型参数的上界，即限制类型参数为某个特定类或其子类。这允许在泛型方法或类中使用该上界类型的属性和方法。

```java
public class NumericUtils<T extends Number> {
    private T number;
    
    public NumericUtils(T number) {
        this.number = number;
    }
    
    public double doubleValue() {
        return number.doubleValue();
    }
}
```

### 多重上界限制

一个类型参数可以有多个上界限制，通过 `&` 运算符来结合。这种情况下，类型参数必须同时满足所有指定的上界条件。

```java
public class BoundedType<T extends Number & Comparable<T>> {
    private T value;
    
    public BoundedType(T value) {
        this.value = value;
    }
    
    public boolean isGreaterThan(T other) {
        return value.compareTo(other) > 0;
    }
}
```

## 类型擦除

Java中的**类型擦除（Type Erasure）**是泛型实现的基础机制。它使得Java编写的泛型代码可以与未使用泛型的旧代码兼容，也是泛型的底层原理的重要实现。

### 概念

类型擦除是指Java编译器在编译泛型代码时，会移除所有的泛型类型信息，将泛型类型替换为其限定的类型或原始类型（通常是 `Object`）。这样，生成的字节码不包含任何泛型类型的信息，运行时的Java虚拟机（JVM）也无法获得这些信息。

### 原理

类型擦除的工作过程可以分为以下几个步骤：

1. 将泛型类型替换为原始类型
    
    编译器会将泛型类型替换为其边界类型（Bounded Type）。如果没有显式指定边界，边界默认是 `Object`。
    
    ```java
    public class Box<T> {
        private T item;
    
        public void setItem(T item) {
            this.item = item;
        }
    
        public T getItem() {
            return item;
        }
    }
    ```
    
    类型擦除之后：
    
    ```java
    public class Box {
        private Object item;
    
        public void setItem(Object item) {
            this.item = item;
        }
    
        public Object getItem() {
            return item;
        }
    }
    ```
    
2. 插入必要的类型转换
    
    在类型擦除之后，由于所有的泛型类型都被替换为 `Object` 或者其他边界类型，编译器会在必要的位置插入强制类型转换。
    
    ```java
    Box<String> stringBox = new Box<>();
    String s = (String) stringBox.getItem(); // 类型转换由编译器插入
    ```
    
3. 删除所有的泛型类型检查代码
    
    编译器会移除与泛型相关的类型检查代码。例如，在类型擦除之后，`instanceof` 检查不再关心泛型类型，只会检查原始类型。
    

### 影响

- 类型参数不能是基本数据类型
    
    `Object`不能持有基本数据类型。
    
- 运行时类型信息的丢失
    
    类型擦除导致在运行时无法知道泛型的实际类型参数。以下代码会在运行时返回 `true`，因为泛型信息被擦除了：
    
    ```java
    List<String> stringList = new ArrayList<>();
    List<Integer> integerList = new ArrayList<>();
    System.out.println(stringList.getClass() == integerList.getClass()); // true
    ```
    
- 泛型实例的创建受限
    
    - 由于类型信息在编译时擦除，无法直接创建泛型类型的实例。例如，`new T()` 是非法的。
    - 同样，也不能创建泛型数组，如 `new T[10]` 或 `new List<String>[10]`。
- 泛型类的静态上下文受限
    
    泛型类型参数在静态上下文中不可用，例如不能在静态字段或静态方法中使用类型参数。
    

### 建议

- 使用明确的边界：如果你知道类型参数的上界，明确指定上界（如 `<T extends Comparable<T>>`）。
- 使用`Class<T>` 进行实例化：为了在某些情况下保留运行时类型信息，可以使用 `Class<T>` 作为辅助，例如 `public <T> T createInstance(Class<T> clazz)`。



