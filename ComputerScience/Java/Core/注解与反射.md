# 注解与反射
## 注解
### 注解概述
- **定义**：注解是一种特殊的接口，前面有一个 `@` 符号，使用 `@interface` 关键字定义。注解可以没有方法或变量。
- 语法：
	```java
	@interface MyAnnotation {
	    String value() default "default";
	    int count() default 0;
	}
	```
- **属性**：注解可以有成员变量，这些成员变量在注解中称为 "元素"。
	- 注解只有成员变量，没有方法，以“无形参方法体的抽象方法”形式声明。
	- 其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。
	- 成员变量只能用 `public` 或默认(`default`) 这两个访问权修饰。
	- 成员变量数据类型只能是内置数据类型。
	- 成员变量可以有默认值，使用 `default` 关键字指定。
- **特点**：
	- 为代码提供元数据，可以用于标记、信息传递、文档生成、代码分析和代码生成等用途。
	- 可以在编译，类加载，运行时被读取，并执行相应的处理，可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。
	- 提供元数据供工具或框架处理（如 Spring 的 `@Autowired`）。
	- 可通过反射在运行时获取信息。
	- 注解都隐式继承了 `java.lang.annotation.Annotation` 接口，不能再继承别的类或接口。
### 内置注解
- `@Override`：用于标示子类的方法覆盖了父类的方法，帮助编译器检查是否正确重写。
- `@Deprecated`：表示某个元素（类、方法、变量等）已过时，不推荐使用。
- `@SuppressWarnings`：用于抑制编译器产生的警告信息。
- `@FunctionalInterface`：用于声明接口是一个函数式接口（只有一个抽象方法）。
### 元注解
- 元注解是定义其它注解的注解。
- **@Target**
	- 定义：指定注解可以用于的程序元素类型（如类、方法、字段等）。
	- 可选值：
		- `ElementType.TYPE`：类、接口、枚举
	    - `ElementType.FIELD`：字段
	    - `ElementType.METHOD`：方法
	    - `ElementType.PARAMETER`：方法参数
	    - `ElementType.CONSTRUCTOR`：构造方法
	    - `ElementType.LOCAL_VARIABLE`：局部变量
	    - ANNOTATION_TYPE
	    - PACKAGE
	    - TYPE_PARAMETER
	    - TYPE_USE
	- 示例：
		```java
		@Target(ElementType.METHOD)
		@interface MyMethodAnnotation {}
		```
- **@Retention**
	- 定义：指定注解的保留策略。
	- 可选值：
		- `RetentionPolicy.SOURCE`：注解只在源代码中存在，编译时会被丢弃。
	    - `RetentionPolicy.CLASS`：注解在编译后存在于字节码文件中，但运行时不可见（默认值）。
	    - `RetentionPolicy.RUNTIME`：注解在运行时可见，可通过反射获取。
	- 示例：
		```java
		@Retention(RetentionPolicy.RUNTIME)
		@interface MyRuntimeAnnotation {}
		```
- **@Documented**：标注的注解会包含在 Javadoc 中。
- **@Inherited**：允许子类继承父类的注解（仅适用于类）。
- **@Repeatable**：允许同一元素上多次使用同一注解（Java 8+）。
- **@Native**：表示字段可以被本地方法调用。
### 自定义注解
- **定义**
	- 
- **使用**





### 类型注解






### 注解处理器





## 反射


# 注解

Java 中的注解（Annotations）是用来为代码添加元数据的工具。它们可以用于编译时的检查、运行时的行为修改或用于生成文档。可以把注解理解为代码里的特殊标记，可以在**编译**，**类加载**，**运行**时被读取，并执行相应的处理。使得开发者**可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息**。所有注解都隐式继承了**`java.lang.annotation.Annotation`**接口，不能再继承别的类或接口。

## 基本概念

- **定义**：注解是一种特殊的接口，前面有一个 `@` 符号。注解可以没有方法或变量。
    
- **属性：**注解可以有成员变量，这些成员变量在注解中称为 "元素"。
    
    - 注解只有成员变量，没有方法，以“无形参方法体的抽象方法”形式声明。
    - 其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。
    - 成员变量只能用 `public` 或默认(`default`) 这两个访问权修饰。
    - 成员变量数据类型只能是内置数据类型。
    - 成员变量可以有默认值，使用 `default` 关键字指定。
- **作用**：为代码提供元数据，可以用于标记、信息传递、文档生成、代码分析和代码生成等用途。
    
- **语法**：注解定义使用 `@interface` 关键字
    
    ```java
    public @interface MyAnnotation {
        String value() default "default";
    }
    ```
    

## 内置注解

- `@Override`：用于标示子类的方法覆盖了父类的方法，帮助编译器检查是否正确重写。
- `@Deprecated`：表示某个元素（类、方法、变量等）已过时，不推荐使用。
- `@SuppressWarnings`：用于抑制编译器产生的警告信息。
- `@FunctionalInterface`：用于声明接口是一个函数式接口（只有一个抽象方法）。

## 元注解

元注解是用于定义其他注解的注解。

1. `@Retention`：指定注解的保留策略。
    - `RetentionPolicy.SOURCE`：注解只在源代码中存在，编译时会被丢弃。
    - `RetentionPolicy.CLASS`：注解在编译后存在于字节码文件中，但运行时不可见（默认值）。
    - `RetentionPolicy.RUNTIME`：注解在运行时可见。
2. `@Target`：指定注解可以用于的程序元素类型（如类、方法、字段等）。
    - `ElementType.TYPE`：类、接口、枚举
    - `ElementType.FIELD`：字段
    - `ElementType.METHOD`：方法
    - `ElementType.PARAMETER`：方法参数
    - `ElementType.CONSTRUCTOR`：构造方法
    - `ElementType.LOCAL_VARIABLE`：局部变量
3. `@Documented`：表示使用该注解的元素应被 javadoc 或类似工具文档化。
4. `@Inherited`：允许子类继承父类的注解。
5. `@Repeatable`：表示注解是可重复的。
6. `@Native`：表示字段可以被本地方法调用。

## 自定义注解

- **定义**：通过 `@interface` 定义注解类型，通常需要添加元注解。
    
    ```java
    @Retention(RetentionPolicy.RUNTIME)
    @Target(value = {ElementType.FIELD})
    public @interface MyAnnotation {
        String value() default "default";
    }
    ```
    
- **使用**：注解的应用方式通常是放在类、方法、字段等前面，使用 `@` 加注解名。
    
    ```java
    @MyAnnotation(value = "example")
    public class ExampleClass {}
    ```
    

## 类型注解

- **概念**：类型注解是 Java 8 引入的一种增强注解机制，允许开发者将注解应用到**所有使用类型**的地方，而不仅仅是类、方法、字段等传统位置。
    
- **定义**：需要使用`@Target`指定使用位置
    
    - **`ElementType.TYPE_USE`**：表示注解可以用于任何类型的使用位置。
        
    - **`ElementType.TYPE_PARAMETER`**：表示注解可以用于类型参数声明（例如泛型参数）。
        
        ```java
        import java.lang.annotation.ElementType;
        import java.lang.annotation.Target;
        import java.lang.annotation.Retention;
        import java.lang.annotation.RetentionPolicy;
        
        @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface NonNull {}
        ```
        
- **使用**：类型注解可以应用于任何地方，只要使用了类型，便可以加上注解。
    
    ```java
    // 泛型类型参数
    List<@NonNull String> names; // 表示List中的所有String类型元素不能为空
    // 类型转换
    myStr = (@NonNull String) myObject; // 强制类型转换时的注解
    // 实现接口或继承类
    class MyClass implements @Readonly MyInterface {} // 在实现接口时添加注解
    // 方法的返回类型
    public @Nullable String getName() {
        return null;
    }
    //局部变量
    @Encrypted String data = getEncryptedData(); // 注解局部变量
    // 数组的元素类型
    String @Encrypted [] passwords; // 注解数组元素类型
    ```
    
- 常见类型注解：Java标准库中不包含内置的类型注解，由第三方库提供。
    
    Lombok提供的类型注解：
    
    - **`@NonNull`**：用于确保字段或参数不能为空。Lombok 会为使用 `@NonNull` 的字段或方法参数自动生成空检查逻辑。
        
    - **`@With`**：用于创建不可变对象的“带有”方法，它会生成一个新对象实例，该实例只修改一个字段，其余字段保持不变。
        
        ```java
        // 对象类
        import lombok.With;
        
        public class User {
            private final @With String name;
            private final int age;
        
            public User(String name, int age) {
                this.name = name;
                this.age = age;
            }
        }
        // 使用
        public class Main {
            public static void main(String[] args) {
                User user1 = new User("Alice", 25);
        
                // 使用 withName 方法生成一个新 User 对象，name 修改为 "Bob"
                User user2 = user1.withName("Bob");
        
                System.out.println(user1.getName()); // 输出: Alice
                System.out.println(user2.getName()); // 输出: Bob
            }
        }
        ```
        

## 注解处理器

Java对注解的处理方式有在运行期间通过反射处理，和在编译期间通过注解处理器处理。

- **定义**：注解处理器（Annotation Processor）是 Java 提供的一个工具，用于在**编译期间**扫描和处理代码中的注解。它允许开发者在编译时对代码进行分析和操作，比如生成代码、进行编译时验证、生成文档等。
    
- **原理**：
    
    1. 编译器首先解析源代码，并收集所有使用的注解。
    2. 对于每一个注解，查找并调用与之对应的注解处理器。
    3. 注解处理器执行逻辑，生成新的源代码或其他资源文件。
    4. 编译器继续编译新的源代码，直到所有代码处理完成。
    
    ![[注解和反射--1.png]]
    
- **创建**：注解处理器的核心是 `javax.annotation.processing.Processor` 接口，通常通过继承 `javax.annotation.processing.AbstractProcessor` 类来实现。并覆盖以下几个方法：
    
    - **`getSupportedAnnotationTypes()`**：返回该注解处理器支持处理的注解类型的集合。
        
        ```java
        @Override
        public Set<String> getSupportedAnnotationTypes() {
            return Collections.singleton(MyAnnotation.class.getCanonicalName());
        }
        ```
        
    - **`getSupportedSourceVersion()`**：指定该处理器支持的 Java 版本。
        
        ```java
        @Override
        public SourceVersion getSupportedSourceVersion() {
            return SourceVersion.latestSupported();
        }
        ```
        
    - **`process()`**：核心方法，处理注解的逻辑在此实现。该方法接受两个参数：要处理的注解类型和相关的元素。
        
        ```java
        @Override
        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
            for (TypeElement annotation : annotations) {
                Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith(annotation);
                // 对注解的元素进行处理
            }
            return true; // 表示注解已处理完毕
        }
        ```
        
- **注册**：创建注解处理器之后，通过`META-INF/services/javax.annotation.processing.Processor` 文件（使用Maven构建时在`src/main/resources` 中，否则直接在`src`中）来注册注解处理器。在该文件中，指定实现类的全限定名。
    
    ```java
    com.example.MyAnnotationProcessor
    ```
    
- **使用**：**`getSupportedAnnotationTypes()`**和**`getSupportedSourceVersion()`**方法可以通过注解方法获取信息。
    
    ```java
    @SupportedAnnotationTypes("com.example.MyAnnotation")
    @SupportedSourceVersion(SourceVersion.RELEASE_8)
    public class MyAnnotationProcessor extends AbstractProcessor {
    
        @Override
        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
            for (Element element : roundEnv.getElementsAnnotatedWith(MyAnnotation.class)) {
                // 获取元素信息
                String className = element.getSimpleName().toString();
                // 生成代码或执行其他处理逻辑
                generateClassFile(className);
            }
            return true; // 表示注解处理器已处理完所有注解
        }
    
        private void generateClassFile(String className) {
            // 生成 Java 类文件的逻辑
        }
    }
    ```
    

```java
/*    自定义注解    在类的属性上加上注解，并在运行期间对属性赋上注解属性相应的值，*/
/*    自定义注解*/
@Retention(RetentionPolicy.RUNTIME)
@Target(value = {ElementType.FIELD})
public @interface MyAnnotion {
    String name() default "";
    int age() default 0;
}
/*    实体类*/
@Datapublic
class Student {
    @MyAnnotion(name = "张三")
    private String name;
    @MyAnnotion(age = 18)
    private int age;
}
/*    反射处理*/
public class Main {
    public static void main(String[] args) {
        Student student = new Student();
        Class<? extends Student> clazz = student.getClass();
        Field[] fields = clazz.getDeclaredFields();
        Arrays.asList(fields).forEach(field -> {
            if (field.isAnnotationPresent(MyAnnotion.class)) {
                MyAnnotion annotation = field.getAnnotation(MyAnnotion.class);
                String fieldName = field.getName();
                field.setAccessible(true);
                if ("name".equals(field.getName())) {
                    try {
                        field.set(student, annotation.name());
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException(e);
                    }
                } else if ("age".equals(field.getName())) {
                    try {
                        field.set(student, annotation.age());
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        });
        System.out.println(student);
    }
}
```

# 反射

Java反射机制允许在运行时动态地获取类的结构信息和操作对象。

## 基本概念

- **定义**：反射（Reflection）是指程序在**运行时**能够获取类的信息（包括类的字段、方法、构造函数等），并且可以动态调用这些元素。
- **用途**：主要用于框架，如Spring等，允许创建更加灵活和动态的代码。
- **场景**：依赖注入、ORM映射、Junit动态调用测试方法、序列化和反序列化、代码分析和文档生成等。

## 获取Class对象

- 通过类名字面量获取
    
    ```java
    Class clazz = User.clss;
    ```
    
- 通过类的全限定名获取
    
    ```java
    Class clazz = Class.forName("com.dong.entity.User");
    ```
    
- 通过对象获取
    
    ```java
    Class clazz = user.getClass;
    ```
    
- 通过类加载器获取
    
    ```java
    Class clazz = ClassLoader.getSystemClassLoader().loaderClass("com.dong.entity.User");
    ```
    

## 创建对象实例

- 直接调用`Class`对象的`newInstance()`方法，使用无参构造
    
    ```java
    newInstanceUser user = clazz.newInstance();
    ```
    
- 先获取构造器，通过构造器创建对象
    
    ```java
    Constructor constructor = clazz.getConstructor(String.class,Integer.class);
    User user = constructor.newInstance("大白",22);
    ```
    

## 获取和调用方法

- `java.lang.reflect.Method`：表示类的方法
- **获取多个方法**：
    - `getDeclaredMethods()` ：获取类声明的所有方法，但不包括继承来的方法。
    - `getMethods()` ：获取所有`public`方法，包括父类继承的。
- **获取单个方法**：
    - `getDeclaredMethod(String name, Class<?>... parameterTypes)` ：获取指定方法（包括私有方法）。
    - `getMethod(String name, Class<?>... parameterTypes)` ：获取指定的`public`方法。
- **调用方法**：
    - `invoke(Object obj, Object... args)`：调用方法。

```java
Method method = clazz.getDeclaredMethod("add", Object.class);
method.invoke(arrayListInstance, "new element");
```

## 获取和操作字段

- `java.lang.reflect.Field`：表示类的字段。
- **获取多个字段**：
    - `getDeclaredFields()`：获取类声明的所有字段，但不包括继承来的字段。
    - `getFields()`：获取类的所有`public`字段，包括父类继承的。
- **获取单个字段**：
    - `getDeclaredField(String name)`：获取指定字段（包括私有字段）。
    - `getField(String name)`：获取指定的`public`字段。
- **操作字段**：
    - `setAccessible(true)`：允许访问私有字段。
    - `get(Object obj)`：获取字段值。
    - `set(Object obj, Object value)`：设置字段值。

```java
Field field = clazz.getDeclaredField("size");
field.setAccessible(true);
int size = (int) field.get(arrayListInstance);
```

## 获取和调用构造函数

- `java.lang.reflect.Constructor`：表示类的构造函数。
- **获取多个构造函数**：
    - `getDeclaredConstructors()`：获取类的所有构造函数，但不包括父类继承的。
    - `getConstructors()`：获取类的所有`public`构造函数，包括父类继承的。
- **获取单个构造函数**：
    - `getDeclaredConstructor(Class<?>... parameterTypes)`：获取指定的构造函数（包括私有构造函数）。
    - `getConstructor(Class<?>... parameterTypes)`：获取指定的`public`构造函数。
- **调用构造函数**：
    - `newInstance(Object... initargs)`：调用构造函数创建实例。

```java
Constructor<?> constructor = clazz.getDeclaredConstructor(int.class);
ArrayList<?> arrayListInstance = (ArrayList<?>) constructor.newInstance(10);
```

## 获取类的信息

- `java.lang.Class`：用于表示类和接口。
- **获取类名**：
    - `getName()`：获取完整的类名（包括包名）。
    - `getSimpleName()`：获取类的简单类名。
- **获取包信息**：
    - `getPackage()`：获取包信息。
- **获取父类和接口**：
    - `getSuperclass()`：获取父类的`Class`对象。
    - `getInterfaces()`：获取类实现的所有接口。

## 动态代理

- `java.lang.reflect.Proxy`：用于创建动态代理类。
- 动态代理是一种设计模式，允许在运行时创建实现某个接口的代理类，通常用于AOP（面向切面编程）。
- 使用`java.lang.reflect.Proxy`类创建代理对象。
- 主要方法：
    - `newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)`：创建代理对象。
    - `InvocationHandler`：接口，用于定义代理行为。

## 泛型与反射

泛型的类型擦除使得在运行时无法直接获取泛型的类型信息，但通过反射可以获取一些间接的信息。

- `getGenericSuperclass()`：获取类的泛型父类。
- `getGenericParameterTypes()`：获取方法的泛型参数类型。

## 安全与性能

- **安全**：
    - 反射可以绕过Java的访问控制机制（比如访问私有字段或方法），因此它可能会带来安全隐患。
    - Java的安全管理器（SecurityManager）可以限制反射的使用。
- **性能**：
    - 由于反射需要进行类型检查和动态绑定，性能比普通的直接调用要低。
    - 频繁使用反射可能会影响程序性能，因此应避免在性能关键的地方使用反射。


