# 面向对象
## 类
### 类的概述



### 类的声明




### 属性与方法




### 封装
- 




### 内部类
- **成员内部类**
	- 定义：定义在类内部，作为类的一个成员。
	- 示例：
		```java
		class OuterClass {
		    private String outerField = "Outer Field";
		
		    // 成员内部类
		    class InnerClass {
		        void display() {
		            System.out.println("Accessing: " + outerField); // 可以访问外部类的成员
		        }
		    }
		}
		// 调用
		OuterClass outer = new OuterClass();
		OuterClass.InnerClass inner = outer.new InnerClass(); // 创建内部类对象
		inner.display();
		```
	- 注意：
		- 成员内部类是非静态的，依赖于外部类的实例，因此它不能包含任何静态变量或静态方法。
		- 成员内部类对象的创建必须依赖于外部类对象。
		- 外部类要访问内部类成员时，需要先创建内部类实例。
		- 当外部类和内部类拥有同名成员，在内部调用会默认使用内部类的，如需调用外部类成员，需要 `外部类类名.this.成员名`。
- **局部内部类**
	- 定义：定义在方法或代码块内部，仅方法内可见。
	- 示例：
		```java
		class OuterClass {
		    void outerMethod() {
		        int localVar = 10; // 必须是有效final的变量
		
		        // 局部内部类
		        class LocalInnerClass {
		            void display() {
		                System.out.println("Accessing local variable: " + localVar);
		            }
		        }
		
		        LocalInnerClass localInner = new LocalInnerClass();
		        localInner.display();
		    }
		}
		```
	- 注意：
		- 局部内部类的作用范围仅限于其所在的方法或代码块。
		- 如果局部内部类的实例传递到了方法之外，则方法结束之后，局部内部类实例仍然存在。
		- 可以访问所在方法的局部变量，但这些变量必须被声明为 `final`
		    - 在 Java 8 之前，局部内部类只能访问方法中的那些被明确声明为 `final` 的局部变量。
		    - 从 Java8 开始，局部内部类可以访问虽然没有被声明为`final`，但却为“有效`final`”的局部变量。
		- 局部内部类同局部变量类似，不能被 `public`, `private`, `protected`, `static` 修饰。
- **匿名内部类**
	- 定义：无名称，用于实现接口或继承类的临时对象。
	- 示例：
		```java
		interface Greeting {
		    void sayHello();
		}
		
		class OuterClass {
		    void outerMethod() {
		        // 匿名内部类实现接口
		        Greeting greeting = new Greeting() {
		            @Override
		            public void sayHello() {
		                System.out.println("Hello from Anonymous Inner Class");
		            }
		        };
		        greeting.sayHello();
		    }
		}
		//---------
		interface Greeting {
		    void sayHello();
		}
		
		class OuterClass {
		    void method(Greeting greeting){
		        greeting.sayHello();
		    }
				// 匿名内部类在传入的参数列表中实现接口
		    public static void main(String[] args) {
		        new OuterClass().method(new Greeting() {
		            @Override
		            public void sayHello() {
		                System.out.println("hello");
		            }
		        });
		    }
		}
		```
	- 注意：
		- 不能有构造方法（因为没有类名），也是唯一没有构造方法的类。
		- 通常用于简化代码，当需要创建一个简单的类的实例，并且只使用一次时。
		- 可以是实现接口的匿名类或扩展类的匿名类。
- **静态内部类**
	- 定义：使用 `static` 修饰的成员类，类似静态成员。
	- 示例：
		```java
		class OuterClass {
		    static String staticField = "Static Field";
		
		    // 静态内部类
		    static class StaticNestedClass {
		        void display() {
		            System.out.println("Accessing static field: " + staticField);
		        }
		    }
		}
		// 调用
		OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
		nestedObject.display();
		```
	- 注意：
		- 可以包含静态成员（静态变量和静态方法）。
		- 不需要外部类的实例就可以创建静态内部类的对象。
		- 只能直接访问外部类的静态成员，不能访问外部类的非静态成员。
## 对象





### 生命周期



m1063637187



## 继承与多态






## 抽象类与接口
### 抽象类





### 接口




8EskcJDJMDqB

Username: QgO6FyskOU                                                                                                                          

Password: g96LaTeWmN                                                                                                                          

Port: 6999                                                                                                                                    

WebBasePath: DidxQnZZNbfEQu1zsD                                                                                                               

Access URL: http://74.211.104.95:6999/DidxQnZZNbfEQu1zsD


ee661e1881


1f82917f60

## 包








# 类

类是对象的蓝图和模板，是一类具有相同属性（成员变量）和行为（方法）的事物的抽象。

## 类的定义

类使用关键字 `class` 定义，类的定义通常包括类名、[属性](https://www.notion.so/114d8cc54819454f9ad096b1f1c68b52?pvs=21)、[方法](https://www.notion.so/114d8cc54819454f9ad096b1f1c68b52?pvs=21)、构造方法等。

```java
class ClassName {
    // 属性（成员变量）
    DataType variableName;

    // 构造方法
    ClassName() {
        // 构造方法的代码
    }

    // 方法（成员方法）
    ReturnType methodName(Parameters) {
        // 方法体
    }
}
```

## 构造方法

- 构造方法（Constructor）是用于创建对象时调用的方法，用于初始化对象的状态。
- 构造方法名称必须与类名相同，并且没有返回类型。
- 可以定义多个构造方法（构造方法的重载），以不同的参数列表来初始化对象。
- 如果没有定义构造方法，Java会提供一个默认的无参构造方法。
- 如果自定义了构造方法，将不会提供默认的无参构造方法。

```java
class ClassName {
    // 构造方法
    ClassName() {
        // 构造代码
    }

    ClassName(int parameter) {
        // 构造代码
    }
}
```

相比于`setter`方法，含参构造方法在创建对象时，强制要求必要的信息，避免不完整的对象状态，比如创建银行账户，必须要求指定账户号和初始金额；又比如在用户注册时，必须要求提供用户名和密码。如果不在创建对象是要求这些必要的信息，那么创建的对象状态将是不完整的，存在潜在的风险，在这种情况下使用含参构造方法就要比`setter`方法更为符合。

## 主方法

## 内部类

Java 支持在类内部定义类，这些类称为内部类。提供代码的封装性，但也会使代码变得复杂。

### 成员内部类

成员内部类是定义在一个类的内部，且在方法或代码块外部，作为类的一个成员，可以访问外部类所有成员（包括私有成员）。

- 成员内部类是非静态的，依赖于外部类的实例，因此它不能包含任何静态变量或静态方法。
- 成员内部类对象的创建必须依赖于外部类对象。
- 外部类要访问内部类成员时，需要先创建内部类实例。
- 当外部类和内部类拥有同名成员，在内部调用会默认使用内部类的，如需调用外部类成员，需要`外部类类名.this.成员名`。

```java
class OuterClass {
    private String outerField = "Outer Field";

    // 成员内部类
    class InnerClass {
        void display() {
            System.out.println("Accessing: " + outerField); // 可以访问外部类的成员
        }
    }
}
```

使用方法：

```java
OuterClass outer = new OuterClass();
OuterClass.InnerClass inner = outer.new InnerClass(); // 创建内部类对象
inner.display();
```

### 局部内部类

局部内部类是在方法或代码块（如构造方法、普通方法、静态方法或一个局部代码块）中定义的类。

- 局部内部类的作用范围仅限于其所在的方法或代码块。
- 如果局部内部类的实例传递到了方法之外，则方法结束之后，局部内部类实例仍然存在。
- 可以访问所在方法的局部变量，但这些变量必须被声明为 `final`
    - 在 Java 8 之前，局部内部类只能访问方法中的那些被明确声明为 `final` 的局部变量。
    - 从 Java8 开始，局部内部类可以访问虽然没有被声明为`final`，但却为“有效`final`”的局部变量
- 局部内部类同局部变量类似，不能被 `public`, `private`, `protected`, `static` 修饰。

```java
class OuterClass {
    void outerMethod() {
        int localVar = 10; // 必须是有效final的变量

        // 局部内部类
        class LocalInnerClass {
            void display() {
                System.out.println("Accessing local variable: " + localVar);
            }
        }

        LocalInnerClass localInner = new LocalInnerClass();
        localInner.display();
    }
}
```

### 匿名内部类

匿名内部类是没有名称的内部类，通常用于实现接口或继承类，并只需要一次使用的情况。它是在使用时直接定义和实例化的类。

- 不能有构造方法（因为没有类名），也是唯一没有构造方法的类。
- 通常用于简化代码，当需要创建一个简单的类的实例，并且只使用一次时。
- 可以是实现接口的匿名类或扩展类的匿名类。

```java
interface Greeting {
    void sayHello();
}

class OuterClass {
    void outerMethod() {
        // 匿名内部类实现接口
        Greeting greeting = new Greeting() {
            @Override
            public void sayHello() {
                System.out.println("Hello from Anonymous Inner Class");
            }
        };
        greeting.sayHello();
    }
}

```

或：

```java
interface Greeting {
    void sayHello();
}

class OuterClass {
    void method(Greeting greeting){
        greeting.sayHello();
    }
		// 匿名内部类在传入的参数列表中实现接口
    public static void main(String[] args) {
        new OuterClass().method(new Greeting() {
            @Override
            public void sayHello() {
                System.out.println("hello");
            }
        });
    }
}
```

### 静态内部类

静态内部类是用 `static` 修饰的内部类，它与外部类的实例没有绑定关系。静态内部类属于外部类的一个静态成员，可以像外部类的其他静态成员一样访问。

- 可以包含静态成员（静态变量和静态方法）。
- 不需要外部类的实例就可以创建静态内部类的对象。
- 只能直接访问外部类的静态成员，不能访问外部类的非静态成员。

```java
class OuterClass {
    static String staticField = "Static Field";

    // 静态内部类
    static class StaticNestedClass {
        void display() {
            System.out.println("Accessing static field: " + staticField);
        }
    }
}
```

使用方法：

```java
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
nestedObject.display();
```

# 对象

对象是类的实例，通过类的模板来创建具体的对象。

## 对象的定义

- 对象（Object）是一个实体，它由属性和行为组成。对象包含了类的实例化数据（属性的值）和方法的具体实现。
- 每个对象都占用内存空间，用于存储其状态（属性值）和行为（方法）。

## 创建对象

对象是通过`new`关键字创建的。

```java
ClassName objectName = new ClassName();
```

`objectName`是对象的引用变量。

创建对象的过程包括以下几个步骤：

1. **声明对象引用变量**：声明一个类类型的变量，用于保存对象的引用。
2. **实例化对象**：使用 `new` 关键字调用类的构造方法，分配内存空间并创建对象。
3. **初始化对象**：构造方法会初始化对象的属性。

## 对象的生命周期

对象的生命周期包括创建、使用、和销毁三个阶段。

- **创建**：对象的创建是通过 `new` 关键字和构造方法完成的。
- **使用**：对象在被引用时可以调用其方法或访问其属性。
- **销毁**：对象的生命周期结束时，Java 垃圾回收机制（Garbage Collector）会自动销毁不再被引用的对象，释放内存。

## 对象的引用

首先要知道对象的变量存储的是对象的内存地址，所以在对象引用时传递的是对象地址

多个引用变量会指向同一个对象，这就是 Java 的值传递

```java
Car car1 = new Car();
Car car2 = car1;  // car2 引用 car1 指向的同一个对象，修改car1的属性，car2跟着改变
```

## 对象的比较

- 使用 `==` 比较两个对象时，比较的是对象的引用（即内存地址）。
- 使用 `equals()` 方法比较对象时，比较的是对象的内容。默认情况下，`Object` 类的 `equals()` 方法与 `==` 等效，但可以在类中重写 `equals()` 方法来比较对象的实际内容。

## 对象的克隆

- 对象的克隆是创建一个与现有对象相同的新对象。Java 提供了 `clone()` 方法和 `Cloneable` 接口来实现对象克隆。
- 重写 `clone()` 方法时，通常需要进行深拷贝（创建对象的深层副本）或浅拷贝（只复制对象的引用）。

## 对象的垃圾回收

- Java 有一个自动的垃圾回收机制（Garbage Collector），用于回收那些不再被任何对象引用的对象内存。
- 开发者可以通过调用 `System.gc()` 建议 JVM 执行垃圾回收，但不能保证立即执行。

## `this`关键字

`this` 关键字用于引用当前对象。在方法或构造方法内部使用 `this` 可以访问该对象的成员变量和方法。

this用在方法中，如果某个对象调用了该方法，则this表示该对象

```java
public class Animal {
    private String name;

    public Animal(String name) {
        this.name = name; // this 关键字引用当前对象的 name 属性
    }
}
```

## `toString()` 方法

- `toString()` 方法用于返回对象的字符串表示形式。每个类都继承自 `Object` 类，默认的 `toString()` 方法返回的是对象的类名和哈希码。
- 可以重写 `toString()` 方法以提供更有意义的字符串表示。

```java
@Override
public String toString() {
    return "Car{color='" + color + "', speed=" + speed + "}";
}
```

# 封装

将对象的状态（属性）和行为（方法）封装在一个类中，并通过访问控制来隐藏对象的内部细节，从而只向外界暴露必要的接口。封装的目的是保护数据的完整性和安全性，限制外部对数据的直接访问和修改。

## 封装的定义

- **封装** 是通过将对象的属性设为私有（`private`），并提供公有（`public`）的方法来访问和修改这些属性，以防止外部直接访问和操作对象的内部状态。
- 封装有助于实现数据隐藏（data hiding），使对象的内部表示对外部不可见，从而减少了类之间的耦合。

## 封装的实现方式

封装通常通过将类的属性设为私有（`private`），并提供公有（`public`）的访问器（getter）和修改器（setter）方法来实现。

```java
public class Person {
    // 私有属性，外部无法直接访问
    private String name;
    private int age;

    // 构造方法
    public Person(String name, int age) {
        this.name = name;
        setAge(age);  // 通过 setter 方法设置年龄
    }

    // Getter 方法：获取 name 属性
    public String getName() {
        return name;
    }

    // Setter 方法：设置 name 属性
    public void setName(String name) {
        this.name = name;
    }

    // Getter 方法：获取 age 属性
    public int getAge() {
        return age;
    }

    // Setter 方法：设置 age 属性，带有简单的验证逻辑
    public void setAge(int age) {
        if (age >= 0) {  // 验证年龄是否为非负数
            this.age = age;
        } else {
            System.out.println("年龄不能为负数。");
        }
    }

    // 公有方法：显示人的信息
    public void displayInfo() {
        System.out.println("姓名: " + name + ", 年龄: " + age);
    }
}
```

## 封装的原则

- **属性私有化**：类的所有属性应该声明为 `private`，防止外部直接访问。
- **提供公共访问方法**：使用 `public` 的访问器（getter）和修改器（setter）方法来操作属性，外部只能通过这些方法来访问和修改属性。
- **方法的封装**：不仅仅是属性需要封装，有时方法也需要封装。例如，可以将辅助性的内部方法设为 `private`，使其不能被外部直接调用。
- **不滥用公共访问方法**：虽然 getter 和 setter 方法是封装的一部分，但不应滥用。特别是对于不希望被外部直接修改的属性，不应提供 setter 方法。
- **进行数据验证**：提供 setter 方法时应考虑数据验证，以确保设置的数据有效性。
- **封装与继承**：子类可以通过 `protected` 或 `public` 方法访问父类的私有属性，但不应直接访问父类的私有属性。这样可以保证父类的实现细节对外部（包括子类）保持隐藏。
- **封装的替代**：可以使用**不可变对象**（Immutable Object）来确保对象状态不会被修改，或者使用**工厂方法**来控制对象的创建过程。
- **封装的限制**：在多线程环境中，如果多个线程同时访问和修改共享对象，即使通过封装也无法完全避免数据不一致问题。此时需要使用同步机制（如 `synchronized` 关键字）来确保数据的正确性。

# 继承

继承允许一个类通过扩展另一个类来获取其所有属性和方法。这种机制使得代码的重用、扩展和维护更加容易。

## 继承的定义

- **继承** 是指一个类（子类）从另一个类（父类或超类）中继承属性和方法。子类可以直接访问父类的公有（`public`）和受保护的（`protected`）成员。
- Java 使用 `extends` 关键字来表示继承关系。

```java
public class Animal {
    // 父类的属性和方法
}

public class Dog extends Animal {
    // 子类继承了 Animal 的所有属性和方法
}
```

## 继承的特点

- Java 支持单继承，即一个类只能有一个直接父类。
- Java 支持多层继承，即一个类可以继承另一个类，而该类又继承了另一个父类。
- 子类可以在父类的基础上进行扩展，添加新的功能或修改已有行为。
- 使用继承的代码结构更清晰，当需要修改父类的行为时，只需修改父类，所有子类的行为也会随之改变。
- 子类继承了父类的属性和方法，可以减少代码重复，提升开发效率。
- `final`类不能被继承
- 子类如果调用父类的同名方法，优先调用子类的重写方法，若没有重写再调用父类方法。

## `Super`关键字

- **`super`** 关键字用于调用父类的构造方法、属性和方法。通常用于在子类中访问父类的成员。
- 调用父类的构造方法：在子类的构造方法中，`super()` 用于调用父类的构造方法。必须是构造方法的第一行，否则编译错误。

```java
public class Animal {
    public Animal() {
        System.out.println("Animal constructor");
    }
}

public class Dog extends Animal {
    public Dog() {
        super(); // 调用父类的构造方法
        System.out.println("Dog constructor");
    }
}
```

## 继承与构造方法

- 当创建子类对象时，父类的构造方法会被优先调用。这是因为子类继承了父类的属性，需要通过父类的构造方法来初始化这些属性。
- 如果父类没有无参构造方法，则子类必须显式地调用父类的有参构造方法。

# 多态

多态（Polymorphism）指的是同一个操作或方法可以根据上下文表现出不同的行为。Java 中的多态主要通过**方法重载（编译时多态）和方法重写（运行时多态）**来实现。

## 编译时多态

方法重载是指在同一个类中定义多个同名的方法，但这些方法的参数列表（参数数量、类型、顺序）不同。

- 方法重载在编译时确定哪一个方法将被调用，因此称为编译时多态。
- 重载的方法可以有不同的返回类型，但仅靠返回类型不同无法区分重载。

```java
class MathOperations {
    // 重载方法1：接收两个整数
    public int add(int a, int b) {
        return a + b;
    }

    // 重载方法2：接收三个整数
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // 重载方法3：接收两个浮点数
    public double add(double a, double b) {
        return a + b;
    }
}
```

## 运行时多态

方法重写是指子类提供了一个与父类在方法签名上完全相同的方法实现。

- **方法重写在运行时根据对象的实际类型决定调用哪个方法，因此称为运行时多态。**
- 重写的方法必须具有相同的方法名、参数列表和返回类型。
- 可以通过 `@Override` 注解来确保子类方法是对父类方法的重写。
- 通过**父类引用指向子类对象**，来实现运行时的多态。
- 父类引用不能调用子类的特有方法，需要强转。

```java
class Animal {
    public void sound() {
        System.out.println("动物发出声音");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("狗叫：汪汪");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("猫叫：喵喵");
    }
}

public class Zoo {
    // 利用多态，接受父类引用
    public static void printAnimalSound(Animal animal) {
        animal.sound();  // 实际调用哪个 sound() 取决于传入对象的实际类型
    }

    public static void main(String[] args) {
        Animal myDog = new Dog();  // 父类引用指向子类对象
        Animal myCat = new Cat();

        printAnimalSound(myDog);  // 输出：狗叫：汪汪
        printAnimalSound(myCat);  // 输出：猫叫：喵喵
    }
}
```

## 多态的意义

- **代码的可扩展性和可维护性**：多态使得代码更易于扩展，添加新的子类时无需修改现有代码。
- **降低耦合性**：可以通过接口或父类来编写通用代码，实现不同子类的动态调用。
- **增强灵活性**：可以根据运行时的实际对象类型动态决定调用哪个方法。
- **设计模式的基础：**多态是很多设计模式的核心，比如工厂模式（Factory Pattern）、策略模式（Strategy Pattern）、观察者模式（Observer Pattern）等。通过多态，这些设计模式能够实现对象行为的灵活变化和动态替换。

## **多态的实现条件**

- 必须有继承（或实现）关系。
- 必须有方法重写（Override）。
- 必须通过父类引用指向子类对象来调用被重写的方法。

## 父类引用指向子类对象

- **统一接口**：使用父类或接口类型的引用，使得代码可以处理任意子类对象，而不必关心具体的子类是什么。这样可以通过一个统一的接口操作不同的子类对象。
- **动态绑定**：多态通过动态绑定（运行时决定调用哪个方法）实现，在编译时无法确定具体调用的是哪个子类的方法，而是在运行时根据实际对象的类型来决定调用哪个方法。
- **减少重复代码**：如果直接使用子类引用，可能会导致需要编写大量相似的代码来处理不同的子类。而使用多态可以通过一个统一的父类引用处理所有子类，减少代码重复。

## 多态的实际应用

- **使用接口或抽象类**：在 Java 中，接口或抽象类通常用于定义行为的抽象层，实际的实现类在运行时决定具体的行为。
- **设计模式**：许多设计模式（如工厂模式、策略模式、观察者模式等）都依赖多态来实现对象行为的动态变化。

# 抽象

抽象类和抽象方法用于定义类的骨架，提供一部分通用的实现，同时强制子类去完成特定实现。

## 抽象类

抽象类（Abstract Class）是使用 `abstract` 关键字修饰的类，它可以包含抽象方法（没有方法体的方法）和非抽象方法（有方法体的方法）。抽象类不能被实例化，必须通过子类继承并实现抽象类中的抽象方法。

- **无法实例化**：抽象类不能直接用 `new` 关键字创建实例。
- **包含抽象方法**：一个抽象类可以包含一个或多个抽象方法，也可以没有抽象方法。
- **可包含具体方法**：抽象类不仅仅包含抽象方法，还可以包含具体的方法和静态方法和构造方法。
- **可以有成员变量**：抽象类可以有成员变量和静态变量。
- **支持继承**：子类继承抽象类后，必须实现抽象类的所有抽象方法，否则子类也必须声明为抽象类。
- **构造方法的使用**：抽象类可以有构造方法，用于子类的实例化时调用。

抽象类通常用于表示一个对象的通用概念，多个类共享一个父类时，可以将通用行为和属性放入抽象类中，具体的子类实现具体的行为。

```java
abstract class Animal {
    String name;
    
    // 抽象方法
    abstract void makeSound();
    
    // 具体方法
    void sleep() {
        System.out.println(name + " is sleeping.");
    }
}

class Dog extends Animal {
    // 实现抽象方法
    void makeSound() {
        System.out.println("Woof Woof");
    }
}
```

## 抽象方法

抽象方法（Abstract Method）是没有方法体的方法，它只定义方法的签名（名称、返回类型、参数），而不提供具体的实现。抽象方法必须使用 `abstract` 关键字修饰，且只能在抽象类或接口中定义。

- **没有方法体**：抽象方法只有方法声明，没有方法体。
- **必须在抽象类或接口中**：抽象方法只能在抽象类或接口中定义。
- **子类必须实现**：任何继承抽象类的子类都必须实现所有抽象方法，除非子类本身也是抽象类。

```java
abstract class Vehicle {
    // 抽象方法
    abstract void startEngine();
}

class Car extends Vehicle {
    // 实现抽象方法
    void startEngine() {
        System.out.println("Car engine started.");
    }
}
```

## 抽象类与接口的对比

|特性|抽象类|接口|
|---|---|---|
|实现方法|可以有抽象方法和具体方法|只能有抽象方法（Java 8之后可以有默认方法和静态方法）|
|构造方法|可以有构造方法|不能有构造方法|
|继承限制|一个类只能继承一个抽象类|一个类可以实现多个接口|
|成员变量|可以有成员变量|只能有 `public static final` 常量|
|访问修饰符|可以有任意访问修饰符（`private`, `protected`, `public`）|接口中的方法默认是 `public` 的，不能有 `private` 或 `protected`|

# 接口

**接口（Interface）** 是一种重要的抽象机制，用于定义一组没有具体实现的方法，由实现接口的类来提供具体的行为。接口提供了一种更灵活的多继承机制，并在面向对象编程中起到了规范和解耦的作用。

## 接口的定义

- 接口使用 `interface` 关键字定义。
- 接口中的所有方法默认是 `public` 和 `abstract`，即使不显式声明，JDK8开始接口可以有默认方法和静态方法。
- 接口中可以包含常量（`public static final`），默认为 `public static final`。
- 接口不能包含任何构造方法，因为它不能被实例化。

```java
public interface MyInterface {
    // 接口中的常量
    int MAX_COUNT = 100;  // 等同于 public static final int MAX_COUNT = 100;

    // 接口中的抽象方法
    void abstractMethod();

    // 接口中的默认方法 (Java 8 引入)
    default void defaultMethod() {
        System.out.println("This is a default method in interface.");
    }

    // 接口中的静态方法 (Java 8 引入)
    static void staticMethod() {
        System.out.println("This is a static method in interface.");
    }
}
```

## 接口的实现

- 一个类使用 `implements` 关键字来实现接口，并且必须实现接口中声明的所有抽象方法。
- 一个类可以实现多个接口，解决了 Java 不支持多重继承的限制。

```java
public class MyClass implements MyInterface {
    @Override
    public void abstractMethod() {
        System.out.println("Implemented abstractMethod in MyClass.");
    }

    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.abstractMethod(); // 调用实现的抽象方法
        obj.defaultMethod();  // 调用接口中的默认方法
        MyInterface.staticMethod(); // 调用接口中的静态方法
    }
}
```

## 默认方法和静态方法

**默认方法（Default Methods）**：Java 8 引入的特性，允许在接口中定义**具有方法体**的方法。通过`default`关键字声明。

- 默认方法使接口具有部分实现，可以减少接口变更对实现类的影响。
- 适用于需要在接口中提供某种默认行为的情况。

**静态方法（Static Methods）**：同样是 Java 8 引入的特性，允许在接口中定义静态方法，使用`static`关键字。

- 静态方法只能通过接口本身调用，而不能通过实现类或对象调用。

## 接口的继承

- 接口可以通过 `extends` 关键字继承其他接口，一个接口可以继承多个接口。
- 继承的接口可以组合多个接口的功能。

```java
public interface AdvancedInterface extends MyInterface, AnotherInterface {
    void anotherAbstractMethod();
}
```

## 接口的多态性

- 接口类型的引用可以指向任何实现了该接口的对象，实现了接口的类就可以被认为是该接口的子类型。
- 通过接口类型进行引用，可以实现多态，使用接口引用调用相应的方法。

```java
MyInterface obj = new MyClass(); // 多态，接口引用指向实现类对象
obj.abstractMethod(); // 调用的是 MyClass 实现的方法
```

## 接口的应用场景

- **API 设计**：接口常用于定义模块的行为规范，如 Java 的集合框架。
- **解耦和扩展性**：接口将具体实现和使用分离，增强了代码的灵活性和可维护性。
- **回调机制**：接口可以作为回调函数的类型，通过传递接口类型的对象来实现回调。

## 接口和抽象类的对比

|特性|抽象类|接口|
|---|---|---|
|实现方法|可以有抽象方法和具体方法|只能有抽象方法（Java 8之后可以有默认方法和静态方法）|
|构造方法|可以有构造方法|不能有构造方法|
|继承限制|一个类只能继承一个抽象类|一个类可以实现多个接口|
|成员变量|可以有成员变量|只能有 `public static final` 常量|
|访问修饰符|可以有任意访问修饰符（`private`, `protected`, `public`）|接口中的方法默认是 `public` 的，不能有 `private` 或 `protected`|

## 接口的私有方法

- Java 9 引入了接口的**私有方法**，这些方法只能在接口内部使用，不能被实现类访问。
- 用于避免重复代码和提供更好的代码组织。

```java
public interface MyInterface {
    default void defaultMethod() {
        commonMethod();
    }

    private void commonMethod() {
        System.out.println("This is a private method in the interface.");
    }
}
```

# 包

包（Package）是一个重要的组织结构，用于对类和接口进行分组和管理。通过使用包，可以更好地组织代码、避免命名冲突并控制访问权限。

## 包的定义

**包（Package）** 是一个用于将类、接口、枚举、注解等进行分类存放的命名空间（Namespace）。

主要作用包括：

- **组织类和接口**：将相关的类和接口放在同一个包中，方便管理和使用。
- **避免命名冲突**：不同包中的类可以有相同的名字而不冲突，因为包提供了一个命名空间。
- **访问控制**：包提供了访问级别的划分，可以更好地控制类和成员的可见性。

## 包的命名约定

- Java 包的命名通常采用反向域名系统（DNS）格式，例如：`com.companyname.projectname`。
- 这种命名方式有助于保持包的唯一性，避免冲突。
- 包名通常用小写字母，避免与类名混淆。

## 包的声明

包的声明使用 `package` 关键字，并且必须是Java文件的第一条语句（除非有注释）。

```java
package com.example.myapp;
```

## 包的使用

- 包中的类或接口可以通过**完全限定名**（如 `java.util.ArrayList`）或者**导入语句**来引用。
- 使用 `import` 关键字可以导入一个包或特定的类：

```java
import java.util.List;  // 导入特定类
import java.util.*;     // 导入整个包
```

## 子包

- 包可以有子包，例如，`java.util` 包中有子包 `java.util.concurrent`。
- 子包和父包之间没有特殊的关系，它们只是命名上的层次结构，不继承父包的成员。

## 创建包

在项目中创建包的结构可以通过目录来实现，目录结构应与包的命名保持一致。

```java
com/
  example/
    myapp/
      MyClass.java
```

在 `MyClass.java` 文件中，第一行应该声明包：

```java
package com.example.myapp;
```

## 访问控制与包

Java 的访问控制符与包紧密相关：

- **`public`**: 类或成员对所有类可见。
- **`protected`**: 成员对同一个包中的所有类以及其他包中的子类可见。
- **`default`（包级访问）**: 如果不指定访问控制符，默认为包级访问，类或成员对同一个包中的类可见。
- **`private`**: 成员仅对定义它的类可见。

## 打包与发布

- Java 项目在发布时常常将包组织成 JAR（Java Archive）文件。
- 使用 `jar` 命令可以将包压缩成一个 JAR 文件，方便分发和部署。

## 包的命名冲突

如果两个包中的类有相同的名称，可以使用类的**完全限定名**来避免冲突。例如：

```java
java.util.Date date1 = new java.util.Date();
java.sql.Date date2 = new java.sql.Date(System.currentTimeMillis());
```

## 常用的标准包

- **`java.lang`**：包含基础类库，如 `Object`, `String`, `System` 等，默认自动导入。
- **`java.util`**：包含实用工具类库，如集合框架（`List`, `Set`, `Map`），日期类，随机数生成器等。
- **`java.io`**：包含输入输出操作的类，如 `File`, `InputStream`, `OutputStream` 等。
- **`java.net`**：包含网络通信相关的类，如 `Socket`, `URL`, `URLConnection` 等。
- **`java.sql`**：包含JDBC（Java Database Connectivity）相关的类，用于数据库操作。

# JavaBean

**JavaBean** 是一种符合特定规范的 Java 类，用于封装多个对象的属性，通常用于在 Java 应用程序中共享数据。JavaBean 是可复用的软件组件，广泛用于开发企业级应用程序，特别是在 Java EE（Enterprise Edition） 环境下。

## JavaBean特点

- **公共的无参构造方法**：
    - JavaBean 必须有一个无参的公共构造方法。这样可以使得该类易于创建和管理对象实例，特别是对于框架或工具类库来说，这一点很重要。
- **私有的属性（成员变量）**：
    - JavaBean 的所有属性通常使用 `private` 关键字声明。这样可以确保数据的封装性，防止直接对属性进行访问或修改。
- **公共的 getter 和 setter 方法**：
    - 每个属性都有对应的公共 `getter` 和 `setter` 方法，用于访问和更新属性值。
    - `getter` 方法的命名规范为 `getPropertyName`，`setter` 方法的命名规范为 `setPropertyName`，其中 `PropertyName` 是属性名的首字母大写形式。
    - 如果属性是布尔类型（`boolean`），其 `getter` 方法可以使用 `isPropertyName` 作为命名规范。
- **可序列化（Serializable）**：
    - JavaBean 通常实现 `java.io.Serializable` 接口，以便支持对象的序列化（将对象的状态转换为字节流，便于存储或传输）。

```java
import java.io.Serializable;

public class Person implements Serializable {
    private String name;  // 属性
    private int age;      // 属性

    // 无参构造方法
    public Person() {
    }

    // 带参数的构造方法
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Getter 和 Setter 方法
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

## JavaBean的用途

- **数据传输对象（DTO）**：JavaBean 常用于传递数据，例如在 Java EE 环境中，JavaBean 常用来在表示层（如 JSP 页面）和业务层（如 Servlet）之间传递数据。
- **GUI 开发**：JavaBean 在图形用户界面（GUI）开发中常用来代表组件的属性（如按钮的文本、标签的内容等），并允许通过反射或工具来操作这些属性。
- **企业级应用程序**：在 Java EE 中，JavaBean 可以用于封装业务逻辑中的状态信息或共享数据。

# Lombok

**Lombok** 是一个用于简化 Java 代码的开源库，通过注解自动生成常用代码，从而减少样板代码（boilerplate code）。Lombok 使用注解处理器（Annotation Processor）在编译时自动生成代码，比如 `getter`、`setter`、`equals`、`hashCode`、`toString` 方法、构造函数等，使开发者不再需要手动编写这些重复性的代码。

## Lombok的主要注解

### `@Getter` 和 `@Setter`

- 自动生成指定字段的 `getter` 和 `setter` 方法。
- 可以应用于类上，生成该类中所有字段的 `getter` 和 `setter` 方法，或者直接应用于具体字段。

```java
import lombok.Getter;
import lombok.Setter;

public class Person {
    @Getter @Setter
    private String name;

    @Getter @Setter
    private int age;
}
```

### `@ToString`

- 自动生成 `toString()` 方法，用于生成对象的字符串表示形式。
- 可以通过参数指定是否包含某些字段或调用父类的 `toString()` 方法。

```java
import lombok.ToString;

@ToString
public class Person {
    private String name;
    private int age;
}
```

### `@EqualsAndHashCode`

- 自动生成 `equals()` 和 `hashCode()` 方法，基于类的字段进行对象相等性比较和哈希码计算。
- 可以通过参数指定哪些字段需要包含在 `equals` 和 `hashCode` 方法中。

```java
import lombok.EqualsAndHashCode;

@EqualsAndHashCode
public class Person {
    private String name;
    private int age;
}
```

### `@…ArgsConstructor`

- 自动生成不同类型的构造方法。
- `@NoArgsConstructor`：生成无参构造方法。
- `@AllArgsConstructor`：生成包含所有字段的构造方法。
- `@RequiredArgsConstructor`：生成包含 `final` 字段或带 `@NonNull` 注解字段的构造方法。

```java
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@NoArgsConstructor
@AllArgsConstructor
public class Person {
    private String name;
    private int age;
}
```

### `@Data`

- 组合注解，相当于 `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode` 和 `@RequiredArgsConstructor` 注解的集合。
- 通常用于数据类或 DTO 类，使其具备所有常用的特性。

```java
import lombok.Data;

@Data
public class Person {
    private String name;
    private int age;
}
```

### `@Builder`

- 为类生成一个流式（fluent）的构建器（Builder）模式，用于创建对象。
- 常用于需要构建复杂对象的场景，可以大大简化对象创建的代码

```java
import lombok.Builder;

@Builder
public class Person {
    private String name;
    private int age;
}
```

### `@Slf4j`

自动为类生成一个 `org.slf4j.Logger` 日志记录器实例，简化日志记录器的创建。

```java
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class Person {
    public void doSomething() {
        log.info("Doing something...");
    }
}
```

## Lombok技巧

1. 在使用`@Data`时，不想要为某个字段生成`getter`和`setter`方法。
    
    - **`@Getter(AccessLevel.NONE)`**：禁止生成 `getter` 方法。
        
    - **`@Setter(AccessLevel.NONE)`**：禁止生成 `setter` 方法。
        
        ```java
        import lombok.Data;
        import lombok.Getter;
        import lombok.Setter;
        import lombok.AccessLevel;
        
        @Data
        public class Person {
            private String name;
        
            @Getter(AccessLevel.NONE) // 禁止生成 getter 方法
            @Setter(AccessLevel.NONE) // 禁止生成 setter 方法
            private int age; 
        }
        ```
        
2. `@RequiredArgsConstructor` 的使用。
    
    - `@RequiredArgsConstructor` 只会为添加了`final`修饰和`@NonNull`注解的字段生成构造方法。

## 使用Lombok

1. **添加 Lombok 依赖**：
    
    在使用 Maven 构建的项目中，添加以下依赖到 `pom.xml` 文件：
    
    ```xml
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.26</version> <!-- 请确认使用最新版本 -->
        <scope>provided</scope>
    </dependency>
    ```
    
2. **安装 Lombok 插件**：
    
    在 IDE 中（如 IntelliJ IDEA 或 Eclipse），需要安装 Lombok 插件，以支持 Lombok 注解的解析和代码自动生成，Idea中已经自动安装了Lombok插件。











