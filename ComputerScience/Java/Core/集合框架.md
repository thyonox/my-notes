# 集合框架
## 集合框架概述
### 基本概念
- Java 集合框架（Java Collections Framework, JCF）是 Java 提供的一套用于存储和操作一组数据的类和接口的集合。
- 它位于 `java.util` 包中，提供了一种标准化的方式来处理数据集合，如列表、集合、映射等。
- 集合框架的设计目标是提供高性能、易用性和灵活性，适用于各种数据操作场景。
- 集合框架主要由以下三部分组成：
	- **接口**：定义了集合的基本操作，如 List、Set、Map 等。
	- **实现类**：提供了接口的具体实现，如 ArrayList、HashSet、HashMap 等。
	- **算法**：提供对集合操作的通用算法，如排序、查找、遍历等。
### 接口层次
-  `Collection`：所有集合的根接口，定义了通用的集合操作。
-  `List`：有序集合，允许重复元素，支持索引访问。
-  `Set`：无重复元素的集合，通常无序（某些实现除外）。
-  `Map`：键值对映射集合，键唯一，不继承 `Collection`。
-  `Queue`：队列接口，通常用于先进先出（FIFO）场景。
-  `Deque`：双端队列，支持两端操作。
![[Java Doc.png]]
### 多线程处理






## List
### 接口特性
- **有序性**：元素按照插入顺序存储，可以通过索引（从 0 开始）访问。
- **允许重复**：可以存储相同的元素（基于 `equals()` 方法判断）。
- **索引访问**：支持通过索引进行快速访问、修改、插入和删除操作。
- **动态大小**：`List` 的大小可以动态增长或缩减。
- **非线程安全**：`List` 的常见实现类（如 `ArrayList`、`LinkedList`）默认非线程安全，多线程场景需额外处理。
### 常用方法
- **基本操作（继承自 Collection）**
	- `boolean add(E e)`：在列表末尾添加元素。
	- `boolean remove(Object o)`：移除首次出现的指定元素。
	- `boolean contains(Object o)`：检查是否包含指定元素。
	- `int size()`：返回列表中的元素数量。
	- `boolean isEmpty()`：检查列表是否为空。
	- `void clear()`：移除所有元素。
	- `Iterator<E> iterator()`：返回用于遍历的迭代器。
- **索引相关操作**
	- `void add(int index, E element)`：在指定索引插入元素（原索引及后续元素后移）。
	- `E remove(int index)`：移除指定索引的元素（后续元素前移）。
	- `E get(int index)`：获取指定索引的元素。
	- `E set(int index, E element)`：替换指定索引的元素，返回旧元素。
	- `int indexOf(Object o)`：返回首次出现指定元素的索引，未找到返回 `-1`。
	- `int lastIndexOf(Object o)`：返回最后一次出现指定元素的索引，未找到返回 `-1`。
- **子列表操作**
	- `List<E> subList(int fromIndex, int toIndex)`：返回指定范围的子列表视图（包含 `fromIndex`，不包含 `toIndex`）。
- **批量操作**
	- `boolean addAll(Collection<? extends E> c)`：将指定集合的所有元素添加到列表末尾。
	- `boolean addAll(int index, Collection<? extends E> c)`：将指定集合的所有元素插入到指定索引处。
	- `boolean removeAll(Collection<?> c)`：移除列表中包含在指定集合中的所有元素。
	- `boolean retainAll(Collection<?> c)`：仅保留列表中包含在指定集合中的元素。
	- `boolean containsAll(Collection<?> c)`：检查是否包含指定集合中的所有元素。
- **迭代与转换**
	- `ListIterator<E> listIterator()`：返回支持双向遍历的迭代器。
	- `ListIterator<E> listIterator(int index)`：从指定索引开始返回双向迭代器。
	- `Object[] toArray()`：将列表转换为数组。
	- `<T> T[] toArray(T[] a)`：将列表转换为指定类型的数组。
### List实现类
- **ArrayList**
	- **底层结构**：基于动态数组实现，内部使用 `Object[]` 存储元素。
	- **特点**：
		- 随机访问效率高（O(1)）。
		- 插入和删除效率较低（O(n)，因需要移动元素）。
		- 动态扩容：默认容量为10，当容量不足时，自动扩容到当前容量的 1.5 倍。
		- 非线程安全。
	- **适用场景**：适合读多写少、需要快速随机访问的场景，如数据查询、展示列表。
	- **示例**：
		```java
		import java.util.ArrayList;
		import java.util.List;
		
		public class ArrayListExample {
		    public static void main(String[] args) {
		        List<String> list = new ArrayList<>();
		        list.add("Apple");
		        list.add("Banana");
		        list.add(0, "Orange");
		        System.out.println("ArrayList: " + list); // [Orange, Apple, Banana]
		        System.out.println("Element at index 1: " + list.get(1)); // Apple
		    }
		}
		```
- **LinkedList**
	- **底层结构**：基于双向链表实现，每个元素存储为节点，包含对前一个和后一个节点的引用。
	- **特点**：
		- 插入和删除效率高（O(1)，已知节点位置）。
		- 随机访问效率低（O(n)，需从头/尾遍历）。
		- 同时实现了 `List` 和 `Deque` 接口，可用作双端队列。
	- **适用场景**：适合频繁插入和删除的场景，如任务队列、动态列表。
	- **示例**：
		```java
		import java.util.LinkedList;
		import java.util.List;
		
		public class LinkedListExample {
		    public static void main(String[] args) {
		        List<String> list = new LinkedList<>();
		        list.add("Apple");
		        list.add("Banana");
		        list.add("Orange");
		        System.out.println("LinkedList: " + list); // [Apple, Banana, Orange]
		        list.remove(1);
		        System.out.println("After removing index 1: " + list); // [Apple, Orange]
		    }
		}
		```
- **Vector**
	- **底层结构**：类似于 `ArrayList`，基于动态数组实现。
	- **特点**：
		- 线程安全（方法使用 `synchronized` 修饰）。
		- 性能较低，因同步开销较大。
		- 扩容机制：默认扩容为当前容量的 2 倍（可自定义增量）。
		- 已较少使用，推荐使用 `Collections.synchronizedList(new ArrayList<>())` 替代。
	- **适用场景**：需要线程安全的列表，但性能要求不高时。
	- **示例**：
		```java
		import java.util.Vector;
		import java.util.List;
		
		public class VectorExample {
		    public static void main(String[] args) {
		        List<String> vector = new Vector<>();
		        vector.add("Apple");
		        vector.add("Banana");
		        System.out.println("Vector: " + vector); // [Apple, Banana]
		    }
		}
		```
### 遍历方式
- **for 循环（基于索引）**
	- 定义：使用传统的 `for` 循环通过索引访问 `List` 的元素，适用于 `List` 实现类支持随机访问的场景（如 `ArrayList`）。
	- 注意：
		- 对于 `LinkedList`，索引访问效率低（O(n)）。
		- 直接修改 `List`（如 `add` 或 `remove`）可能导致 `ConcurrentModificationException`。
	- 示例：
		```java
		import java.util.ArrayList;
		import java.util.List;
		
		public class ForLoopExample {
		    public static void main(String[] args) {
		        List<String> list = new ArrayList<>();
		        list.add("Apple");
		        list.add("Banana");
		        list.add("Orange");
		
		        for (int i = 0; i < list.size(); i++) {
		            System.out.println("Index " + i + ": " + list.get(i));
		        }
		    }
		}
		```
- **增强型 for 循环（foreach）**
	- 定义：使用增强型 `for` 循环（foreach）遍历 `List`，通过 `Iterable` 接口实现，代码简洁，适用于大多数遍历场景。
	- 注意：
		- 无法直接访问索引。
		- 无法直接修改 `List` 结构（否则抛出 `ConcurrentModificationException`）。
	- 示例：
		```java
		import java.util.ArrayList;
		import java.util.List;
		
		public class ForEachExample {
		    public static void main(String[] args) {
		        List<String> list = new ArrayList<>();
		        list.add("Apple");
		        list.add("Banana");
		        list.add("Orange");
		
		        for (String item : list) {
		            System.out.println(item);
		        }
		    }
		}
		```
- **Iterator 迭代器**
	- 定义：通过 `Iterator` 接口遍历 `List`，提供标准的迭代方式，支持安全的元素删除操作。
	- 注意：
		- 支持在遍历过程中安全删除元素（通过 `Iterator.remove()`）。
		- 适用于所有 `Collection` 子接口，通用性强。
		- 适合单向遍历，不支持双向遍历或索引访问。
		- 不支持修改元素或添加元素。
	- 示例：
		```java
		import java.util.ArrayList;
		import java.util.Iterator;
		import java.util.List;
		
		public class IteratorExample {
		    public static void main(String[] args) {
		        List<String> list = new ArrayList<>();
		        list.add("Apple");
		        list.add("Banana");
		        list.add("Orange");
		
		        Iterator<String> iterator = list.iterator();
		        while (iterator.hasNext()) {
		            String item = iterator.next();
		            if (item.equals("Banana")) {
		                iterator.remove(); // 安全删除
		            } else {
		                System.out.println(item);
		            }
		        }
		        System.out.println("After removal: " + list);
		    }
		}
		```
- **ListIterator 迭代器**
	- 定义：`ListIterator` 是 `List` 专用的迭代器，继承自 `Iterator`，支持双向遍历、添加、修改和删除元素。
	- 注意：
		- 支持双向遍历（`hasNext()` 和 `hasPrevious()`）。
		- 支持添加（`add`）、修改（`set`）和删除（`remove`）元素。
		- 提供索引信息（`nextIndex()` 和 `previousIndex()`）。
		- 从特定索引开始遍历可使用 `listIterator(int index)`。
	- 示例：
		```java
		import java.util.ArrayList;
		import java.util.ListIterator;
		import java.util.List;
		
		public class ListIteratorExample {
		    public static void main(String[] args) {
		        List<String> list = new ArrayList<>();
		        list.add("Apple");
		        list.add("Banana");
		        list.add("Orange");
		
		        ListIterator<String> iterator = list.listIterator();
		        while (iterator.hasNext()) {
		            String item = iterator.next();
		            if (item.equals("Banana")) {
		                iterator.set("Mango"); // 修改元素
		                iterator.add("Grape"); // 添加元素
		            }
		            System.out.println("Index " + iterator.nextIndex() + ": " + item);
		        }
		
		        // 反向遍历
		        while (iterator.hasPrevious()) {
		            String item = iterator.previous();
		            System.out.println("Reverse: " + item);
		        }
		    }
		}
		```
- **forEach 方法（Java 8+）**
	- 定义：Java 8 引入的 `forEach` 方法，基于 `Iterable` 接口，结合 Lambda 表达式或方法引用，提供简洁的遍历方式。
	- 注意：
		- 可轻松并行化（结合 `parallelStream`）。
		- 不支持直接修改 `List` 结构。
		- 无法访问索引（除非手动维护）。
	- 示例：
		```java
		import java.util.ArrayList;
		import java.util.List;
		
		public class ForEachMethodExample {
		    public static void main(String[] args) {
		        List<String> list = new ArrayList<>();
		        list.add("Apple");
		        list.add("Banana");
		        list.add("Orange");
		
		        // 使用 Lambda 表达式
		        list.forEach(item -> System.out.println(item));
		
		        // 使用方法引用
		        list.forEach(System.out::println);
		    }
		}
		```
- **Stream API（Java 8+）**
	- 定义：Java 8 的 Stream API 提供了一种函数式编程方式遍历和处理 `List` 元素，支持过滤、映射、排序等操作。
	- 注意：
		- 支持复杂操作（如过滤、映射、归约）。
		- 支持并行处理（`parallelStream`）。
		- 不适合简单遍历，性能开销可能较大。
		- 不支持直接修改 `List`。
	- 示例：
		```java
		import java.util.ArrayList;
		import java.util.List;
		
		public class StreamExample {
		    public static void main(String[] args) {
		        List<String> list = new ArrayList<>();
		        list.add("Apple");
		        list.add("Banana");
		        list.add("Orange");
		
		        // 简单遍历
		        list.stream().forEach(System.out::println);
		
		        // 过滤并转换
		        list.stream()
		            .filter(item -> item.startsWith("A"))
		            .map(String::toUpperCase)
		            .forEach(System.out::println);
		    }
		}
		```
## Set
### 接口特性
- **不允许重复**：元素唯一，基于 `equals()` 和 `hashCode()` 方法判断是否重复。
- **无序性**：大多数实现（如 `HashSet`）不保证元素插入顺序，但某些实现（如 `LinkedHashSet`、`TreeSet`）提供特定顺序。
- **无索引访问**：不像 `List`，`Set` 不支持通过索引访问元素。
- **动态大小**：`Set` 的大小可以动态增长或缩减。
- **非线程安全**：`Set` 的常见实现类（如 `HashSet`、`LinkedHashSet`、`TreeSet`）默认非线程安全，多线程场景需额外处理。
### 常用方法
- **基本操作**
	- `boolean add(E e)`：添加元素，如果元素已存在（基于 `equals()`），则不添加并返回 `false`。
	- `boolean remove(Object o)`：移除指定元素，返回是否成功。
	- `boolean contains(Object o)`：检查是否包含指定元素。
	- `int size()`：返回集合中的元素数量。
	- `boolean isEmpty()`：检查集合是否为空。
	- `void clear()`：移除所有元素。
	- `Iterator<E> iterator()`：返回用于遍历的迭代器。
- **批量操作**
	- `boolean addAll(Collection<? extends E> c)`：添加指定集合中的所有元素，重复元素被忽略。
	- `boolean removeAll(Collection<?> c)`：移除包含在指定集合中的所有元素。
	- `boolean retainAll(Collection<?> c)`：仅保留包含在指定集合中的元素。
	- `boolean containsAll(Collection<?> c)`：检查是否包含指定集合中的所有元素。
- **转换**
	- `Object[] toArray()`：将集合转换为数组。
	- `<T> T[] toArray(T[] a)`：将集合转换为指定类型的数组。
### Set实现类
- **HashSet**
	- **底层结构**：基于哈希表（`HashMap` 实现，元素存储在 `HashMap` 的键中，值为占位符）。
	- 特点：
		- 元素无序（不保证插入顺序或排序）。
		- 提供 O(1) 平均时间复杂度的添加、删除和查找操作。
		- 非线程安全。
		- 允许 `null` 元素（仅一个）。
	- **适用场景**：需要快速去重和高效查找的场景，如唯一标识符集合、快速检查元素存在性。
	- **示例**：
		```java
		import java.util.HashSet;
		import java.util.Set;
		
		public class HashSetExample {
		    public static void main(String[] args) {
		        Set<String> set = new HashSet<>();
		        set.add("Apple");
		        set.add("Banana");
		        set.add("Apple"); // 重复元素不会添加
		        set.add(null); // 允许 null
		        System.out.println("HashSet: " + set); // [null, Apple, Banana]
		        System.out.println("Contains Apple: " + set.contains("Apple")); // true
		    }
		}
		```
- **LinkedHashSet**
	- **底层结构**：基于哈希表和双向链表，继承自 `HashSet`。
	- **特点**：
	    - 维护插入顺序（元素按添加顺序排列）。
	    - 性能略低于 `HashSet`，因需维护链表。
	    - 非线程安全。
	    - 允许 `null` 元素（仅一个）。
	- **适用场景**：需要去重且保持插入顺序的场景，如日志记录、历史记录。
	- **示例**：
		```java
		import java.util.LinkedHashSet;
		import java.util.Set;
		
		public class LinkedHashSetExample {
		    public static void main(String[] args) {
		        Set<String> set = new LinkedHashSet<>();
		        set.add("Apple");
		        set.add("Banana");
		        set.add("Orange");
		        System.out.println("LinkedHashSet: " + set); // [Apple, Banana, Orange]
		    }
		}
		```
- **TreeSet**
	- **底层结构**：基于红黑树（`TreeMap` 实现，元素存储在 `TreeMap` 的键中）。
	- **特点**：
		- 元素按自然顺序（`Comparable`）或自定义比较器（`Comparator`）排序。
		- 提供 O(log n) 的添加、删除和查找操作。
		- 非线程安全。
		- 不允许 `null` 元素（因需要比较）。
	- **适用场景**：需要去重且排序的场景，如字典序列表、范围查询。
	- **示例**：
		```java
		import java.util.TreeSet;
		import java.util.Set;
		
		public class TreeSetExample {
		    public static void main(String[] args) {
		        Set<String> set = new TreeSet<>();
		        set.add("Banana");
		        set.add("Apple");
		        set.add("Orange");
		        System.out.println("TreeSet: " + set); // [Apple, Banana, Orange]
		    }
		}
		```
### 遍历方式
- **增强型 for 循环（foreach）**
	- 定义：增强型 for 循环（foreach）通过 Iterable 接口遍历 Set 的元素，是最常用的遍历方式，代码简洁，适用于大多数场景。
	- 注意：
		- 适用于所有 Set 实现（HashSet、LinkedHashSet、TreeSet）。
		- 效率与底层实现相关（HashSet 和 LinkedHashSet 为 O(n)，TreeSet 略慢）。
		- 无法直接访问索引或顺序信息（Set 本身无索引）。
		- 直接修改 Set（如 add 或 remove）会导致 ConcurrentModificationException。
	- 示例：
		```java
		import java.util.HashSet;
		import java.util.Set;
		
		public class ForEachExample {
		    public static void main(String[] args) {
		        Set<String> set = new HashSet<>();
		        set.add("Apple");
		        set.add("Banana");
		        set.add("Orange");
		
		        for (String item : set) {
		            System.out.println(item);
		        }
		    }
		}
		```
-  **Iterator 迭代器**
	- 定义：通过 Iterator 接口遍历 Set，提供标准的迭代方式，支持在遍历过程中安全删除元素。
	- 注意：
		- 支持在遍历时安全删除元素（通过 Iterator.remove()）。
		- 适用于所有 Collection 子接口，通用性强。
		- 不支持添加或修改元素。
		- 不支持双向遍历（Set 不支持 ListIterator）。
	- 示例：
		```java
		import java.util.HashSet;
		import java.util.Iterator;
		import java.util.Set;
		
		public class IteratorExample {
		    public static void main(String[] args) {
		        Set<String> set = new HashSet<>();
		        set.add("Apple");
		        set.add("Banana");
		        set.add("Orange");
		
		        Iterator<String> iterator = set.iterator();
		        while (iterator.hasNext()) {
		            String item = iterator.next();
		            if (item.equals("Banana")) {
		                iterator.remove(); // 安全删除
		            } else {
		                System.out.println(item);
		            }
		        }
		        System.out.println("After removal: " + set);
		    }
		}
		```
-  **forEach 方法（Java 8+）**
	- 定义：Java 8 引入的 forEach 方法，基于 Iterable 接口，结合 Lambda 表达式或方法引用，提供简洁的遍历方式。
	- 注意：
		- 不支持直接修改 Set 结构（否则抛出 ConcurrentModificationException）。
		- 无法访问索引或顺序信息。
		- 可与 Stream API 结合进行复杂处理。
	- 示例：
		```java
		import java.util.HashSet;
		import java.util.Set;
		
		public class ForEachMethodExample {
		    public static void main(String[] args) {
		        Set<String> set = new HashSet<>();
		        set.add("Apple");
		        set.add("Banana");
		        set.add("Orange");
		
		        // 使用 Lambda 表达式
		        set.forEach(item -> System.out.println(item));
		
		        // 使用方法引用
		        set.forEach(System.out::println);
		    }
		}
		```
-  **Stream API（Java 8+）**
	- 定义：Java 8 的 Stream API 提供了一种函数式编程方式遍历和处理 Set 元素，支持过滤、映射、排序等操作。
	- 注意：
		- 支持复杂操作（如过滤、映射、归约）。
		- 支持并行处理（`parallelStream`）。
		- 不适合简单遍历，性能开销可能较大。
		- 不支持直接修改 Set。
	- 示例：
		```java
		import java.util.HashSet;
		import java.util.Set;
		
		public class StreamExample {
		    public static void main(String[] args) {
		        Set<String> set = new HashSet<>();
		        set.add("Apple");
		        set.add("Banana");
		        set.add("Orange");
		
		        // 简单遍历
		        set.stream().forEach(System.out::println);
		
		        // 过滤并转换
		        set.stream()
		           .filter(item -> item.startsWith("A"))
		           .map(String::toUpperCase)
		           .forEach(System.out::println);
		    }
		}
		```
	- **其它**
		- 使用`toArray`方法
			- 定义：将`Set`转换为数组，然后使用普通的`for`循环来遍历数组。
			- 示例：
				```java
				Set<String> set = new HashSet<>();
				set.add("Apple");
				set.add("Banana");
				set.add("Orange");
				
				Object[] array = set.toArray();
				for (Object element : array) {
					System.out.println(element);
				}
				```
		- 使用`Spliterator`接口（Java 8+）
			- 定义：`Spliterator`是Java 8引入的一个接口，可以用来分隔和遍历集合中的元素，通常用于并行处理。
			- 示例：
				```java
				Set<String> set = new HashSet<>();
				set.add("Apple");
				set.add("Banana");
				set.add("Orange");
				
				Spliterator<String> spliterator = set.spliterator();
				spliterator.forEachRemaining(System.out::println);
				```
		- 使用`ListIterator`（间接方法）
			- 定义：虽然`Set`接口本身不支持`ListIterator`，但是可以通过将`Set`转换为`List`来间接使用`ListIterator`进行遍历。
			- 示例：
				```java
				Set<String> set = new HashSet<>();
				set.add("Apple");
				set.add("Banana");
				set.add("Orange");
				
				List<String> list = new ArrayList<>(set);
				ListIterator<String> listIterator = list.listIterator();
				while (listIterator.hasNext()) {
					System.out.println(listIterator.next());
				}
				```
## Map
### 接口特性
- **键唯一性**：每个键最多映射到一个值，重复的键会覆盖旧值（基于 `equals()` 和 `hashCode()` 判断）。
- **键值对存储**：每个元素是一个键值对，键和值可以是任意对象（包括 `null`，视实现而定）。
- **无序性**：大多数实现（如 `HashMap`）不保证键值对的顺序，但某些实现（如 `LinkedHashMap`、`TreeMap`）提供特定顺序。
- **快速查找**：通过键提供高效的查找、插入和删除操作。
- **非线程安全**：`Map` 的常见实现类（如 `HashMap`、`LinkedHashMap`、`TreeMap`）默认非线程安全，多线程场景需额外处理。
### 常用方法
- **基本操作**
	- `V put(K key, V value)`：添加或更新键值对，返回旧值（若无旧值返回 `null`）。
	- `V get(Object key)`：获取指定键对应的值，未找到返回 `null`。
	- `V remove(Object key)`：移除指定键的键值对，返回对应的值（未找到返回 `null`）。
	- `boolean containsKey(Object key)`：检查是否包含指定键。
	- `boolean containsValue(Object value)`：检查是否包含指定值。
	- `int size()`：返回键值对数量。
	- `boolean isEmpty()`：检查 `Map` 是否为空。
	- `void clear()`：移除所有键值对。
- **批量操作**
	- `void putAll(Map<? extends K, ? extends V> m)`：将指定 `Map` 的所有键值对添加到当前 `Map`。
	- `boolean removeAll(Collection<?> c)`：移除包含在指定集合中的键对应的键值对（Java 8+）。
	- `boolean retainAll(Collection<?> c)`：仅保留包含在指定集合中的键对应的键值对（Java 8+）。
- **视图操作**
	- `Set<K> keySet()`：返回所有键的 `Set` 视图。
	- `Collection<V> values()`：返回所有值的 `Collection` 视图。
	- `Set<Map.Entry<K, V>> entrySet()`：返回所有键值对的 `Set` 视图（`Map.Entry` 是键值对的接口）。
		- `Map.Entry` 方法：
			- `K getKey()`：获取键。
			- `V getValue()`：获取值。
			- `V setValue(V value)`：更新值。
- **默认方法**
	- `V getOrDefault(Object key, V defaultValue)`：获取键对应的值，若不存在返回默认值。
	- `V putIfAbsent(K key, V value)`：若键不存在则添加键值对，返回旧值或 `null`。
	- `boolean remove(Object key, Object value)`：仅当键映射到指定值时移除，返回是否成功。
	- `V replace(K key, V value)`：替换键对应的值，返回旧值或 `null`。
	- `boolean replace(K key, V oldValue, V newValue)`：仅当键映射到旧值时替换为新值。
	- `V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)`：若键不存在，计算并添加值。
	- `V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)`：若键存在，重新计算值。
	- `V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)`：重新计算键对应的值。
	- `V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)`：合并值，常用于累加操作。
### Map实现类
- **HashMap**
	- **底层结构**：
		- 基于哈希表，键存储在桶（`bucket`）中，处理冲突使用链表或红黑树。
		- Java 8 之前，通过拉链法解决哈希冲突。
		- JDK8 进行了优化，当链表长度大于 8 时，将链表转为红黑树（如果数组长度小于 64，会先对数组进行扩容），减少搜索时间，当树的节点小于 6 时，又会转为单向链表。
		![[Java Doc 1.png]]
	- **特点**：
		- 键值对无序。
		- 提供 O(1) 平均时间复杂度的查找、插入和删除操作。
		- 非线程安全。
		- 允许 `null` 键（仅一个）和 `null` 值。
	- **适用场景**：需要高效键值查找的场景，如缓存、配置表。
	- **示例**：
		```java
		import java.util.HashMap;
		import java.util.Map;
		
		public class HashMapExample {
		    public static void main(String[] args) {
		        Map<String, Integer> map = new HashMap<>();
		        map.put("Apple", 1);
		        map.put("Banana", 2);
		        map.put("Apple", 3); // 覆盖旧值
		        map.put(null, 0); // 允许 null 键
		        System.out.println("HashMap: " + map); // {null=0, Apple=3, Banana=2}
		        System.out.println("Value for Apple: " + map.get("Apple")); // 3
		    }
		}
		```
- **LinkedHashMap**
	- **底层结构**：基于哈希表和双向链表，继承自 `HashMap`。
		![[Java Doc-1.png]]
	- **特点**：
		- 维护插入顺序或访问顺序（通过构造函数指定）。
		- 性能略低于 `HashMap`，因需维护链表。
		- 非线程安全。
		- 允许 `null` 键（仅一个）和 null 值。
	- **适用场景**：需要保持插入顺序或实现 LRU（最近最少使用）缓存。
	- **示例**：
		```java
		import java.util.LinkedHashMap;
		import java.util.Map;
		
		public class LinkedHashMapExample {
		    public static void main(String[] args) {
		        Map<String, Integer> map = new LinkedHashMap<>();
		        map.put("Apple", 1);
		        map.put("Banana", 2);
		        map.put("Orange", 3);
		        System.out.println("LinkedHashMap: " + map); // {Apple=1, Banana=2, Orange=3}
		    }
		}
		```
- **TreeMap**
	- **底层结构**：基于红黑树，键按自然顺序或自定义比较器排序。
	- **特点**：
		- 键按排序顺序存储。
		- 提供 O(log n) 的查找、插入和删除操作。
		- 非线程安全。
		- 不允许 `null` 键（因需要比较），允许 `null` 值。
	- **适用场景**：需要按键排序的场景，如字典、范围查询。
	- **示例**：
		```java
		import java.util.TreeMap;
		import java.util.Map;
		
		public class TreeMapExample {
		    public static void main(String[] args) {
		        Map<String, Integer> map = new TreeMap<>();
		        map.put("Banana", 2);
		        map.put("Apple", 1);
		        map.put("Orange", 3);
		        System.out.println("TreeMap: " + map); // {Apple=1, Banana=2, Orange=3}
		    }
		}
		```
- **Hashtable**
	- **底层结构**：基于哈希表，类似于 `HashMap`。
	- **特点**：
		- 线程安全（方法使用 `synchronized` 修饰）。
		- 性能较低，因同步开销较大。
		- 不允许 `null` 键或 `null` 值。
		- 已较少使用，推荐使用 `ConcurrentHashMap` 替代。
	- **适用场景**：需要线程安全的键值存储，但性能要求不高。
	- **示例**：
		```java
		import java.util.Hashtable;
		import java.util.Map;
		
		public class HashtableExample {
		    public static void main(String[] args) {
		        Map<String, Integer> map = new Hashtable<>();
		        map.put("Apple", 1);
		        map.put("Banana", 2);
		        System.out.println("Hashtable: " + map); // {Banana=2, Apple=1}
		    }
		}
		```
### 遍历方式
- **通过 keySet() 遍历键**
	- 定义：使用 Map.keySet() 获取所有键的 Set 视图，然后遍历键并通过 Map.get() 获取对应的值。
	- 注意：
		- 适合只需要访问键或通过键查找值的场景。
		- 每次调用 get() 可能导致额外查找（对于 HashMap 为 O(1)，TreeMap 为 O(log n)）。
		- 性能略低于 entrySet()，因为需要额外查询值。
		- 不支持直接修改键值对。
	- 示例：
		```java
		import java.util.HashMap;
		import java.util.Map;
		import java.util.Set;
		
		public class KeySetExample {
		    public static void main(String[] args) {
		        Map<String, Integer> map = new HashMap<>();
		        map.put("Apple", 1);
		        map.put("Banana", 2);
		        map.put("Orange", 3);
		
		        Set<String> keys = map.keySet();
		        for (String key : keys) {
		            System.out.println(key + ": " + map.get(key));
		        }
		    }
		}
		```
-  **通过 values() 遍历值**
	- 定义：使用 Map.values() 获取所有值的 Collection 视图，然后遍历值。
	- 注意：
		- 适合只需要访问值的场景。
		- 无法访问键信息。
		- 不支持直接修改键值对。
		- 值可能重复，需注意去重需求。
	- 示例：
		```java
		import java.util.HashMap;
		import java.util.Map;
		import java.util.Collection;
		
		public class ValuesExample {
		    public static void main(String[] args) {
		        Map<String, Integer> map = new HashMap<>();
		        map.put("Apple", 1);
		        map.put("Banana", 2);
		        map.put("Orange", 3);
		
		        Collection<Integer> values = map.values();
		        for (Integer value : values) {
		            System.out.println("Value: " + value);
		        }
		    }
		}
		```
-  **通过 entrySet() 遍历键值对**
	- 定义：使用 Map.entrySet() 获取所有键值对的 Set 视图（Map.Entry 对象），直接访问键和值，是最常用的 Map 遍历方式。
	- 注意：
		- 性能最高，键值对一次获取，避免额外查找。
		- 支持通过 setValue() 修改值。
		- 不支持直接添加或删除键值对（需通过 Map 操作）。
		- 直接修改 Map 可能导致 ConcurrentModificationException。
	- 示例：
		```java
		import java.util.HashMap;
		import java.util.Map;
		import java.util.Set;
		
		public class EntrySetExample {
		    public static void main(String[] args) {
		        Map<String, Integer> map = new HashMap<>();
		        map.put("Apple", 1);
		        map.put("Banana", 2);
		        map.put("Orange", 3);
		
		        Set<Map.Entry<String, Integer>> entries = map.entrySet();
		        for (Map.Entry<String, Integer> entry : entries) {
		            System.out.println(entry.getKey() + ": " + entry.getValue());
		            // 修改值
		            if (entry.getKey().equals("Banana")) {
		                entry.setValue(20);
		            }
		        }
		        System.out.println("After modification: " + map);
		    }
		}
		```
-  **增强型 for 循环（foreach）**
	- 定义：增强型 for 循环通常结合 entrySet() 或 keySet() 遍历 Map，是上述方式的简化形式，代码简洁。
	- 注意：
		- 结合 entrySet() 效率高，适合大多数场景。
		- 直接修改 Map（如 put 或 remove）会导致 ConcurrentModificationException。
		- 无法直接访问索引。
	- 示例：
		```java
		import java.util.HashMap;
		import java.util.Map;
		
		public class ForEachLoopExample {
		    public static void main(String[] args) {
		        Map<String, Integer> map = new HashMap<>();
		        map.put("Apple", 1);
		        map.put("Banana", 2);
		        map.put("Orange", 3);
		
		        // 使用 entrySet
		        for (Map.Entry<String, Integer> entry : map.entrySet()) {
		            System.out.println(entry.getKey() + ": " + entry.getValue());
		        }
		    }
		}
		```
-  **Iterator 迭代器**
	- 定义：通过 Iterator 接口遍历 Map 的 entrySet() 或 keySet()，支持在遍历过程中安全删除键值对。
	- 注意：
		- 支持安全删除（通过 Iterator.remove()）。
		- 适用于所有 Map 实现，通用性强。
		- 不支持直接添加或修改值（可用 entry.setValue() 间接修改）。
	- 示例：
		```java
		import java.util.HashMap;
		import java.util.Iterator;
		import java.util.Map;
		
		public class IteratorExample {
		    public static void main(String[] args) {
		        Map<String, Integer> map = new HashMap<>();
		        map.put("Apple", 1);
		        map.put("Banana", 2);
		        map.put("Orange", 3);
		
		        Iterator<Map.Entry<String, Integer>> iterator = map.entrySet().iterator();
		        while (iterator.hasNext()) {
		            Map.Entry<String, Integer> entry = iterator.next();
		            if (entry.getKey().equals("Banana")) {
		                iterator.remove(); // 安全删除
		            } else {
		                System.out.println(entry.getKey() + ": " + entry.getValue());
		            }
		        }
		        System.out.println("After removal: " + map);
		    }
		}
		```
-  **forEach 方法（Java 8+）**
	- 定义：Java 8 引入的 Map.forEach 方法，使用 Lambda 表达式或方法引用直接遍历键值对，代码简洁。
	- 注意：
		- 直接访问键和值。
		- 不支持直接修改 Map 结构（否则抛出 ConcurrentModificationException）。
	- 示例：
		```java
		import java.util.HashMap;
		import java.util.Map;
		
		public class ForEachMethodExample {
		    public static void main(String[] args) {
		        Map<String, Integer> map = new HashMap<>();
		        map.put("Apple", 1);
		        map.put("Banana", 2);
		        map.put("Orange", 3);
		
		        // 使用 Lambda 表达式
		        map.forEach((key, value) -> System.out.println(key + ": " + value));
		    }
		}
		```
-  **Stream API（Java 8+）**
	- 定义：Java 8 的 Stream API 通过 entrySet().stream() 或 keySet().stream() 遍历 Map，支持过滤、映射、排序等复杂操作。
	- 注意：
		- 支持复杂操作（如过滤、映射、排序）。
		- 支持并行处理（parallelStream）。
		- 不支持直接修改 Map。
	- 示例：
		```java
		import java.util.HashMap;
		import java.util.Map;
		
		public class StreamExample {
		    public static void main(String[] args) {
		        Map<String, Integer> map = new HashMap<>();
		        map.put("Apple", 1);
		        map.put("Banana", 2);
		        map.put("Orange", 3);
		
		        // 简单遍历
		        map.entrySet().stream()
		           .forEach(entry -> System.out.println(entry.getKey() + ": " + entry.getValue()));
		
		        // 过滤并转换
		        map.entrySet().stream()
		           .filter(entry -> entry.getValue() > 1)
		           .map(entry -> entry.getKey().toUpperCase() + ": " + entry.getValue())
		           .forEach(System.out::println);
		    }
		}
		```









# 定制排序

定制排序是自定义对象的排序规则，主要通过`Comparator`接口的`compare()`方法和`Comparable`接口的`compareTo()`方法来实现。在集合框架中对有序的集合为`List`类，`Set`的`TreeSet`和`LinkdeHashSet`，`Map`的`TreeMap`和`LinkedHashMap`。

## `Comparator`接口

`Comparator`接口是Java中用于定制排序的一种函数式接口。它位于`java.util`包下，提供了对任意类型的对象进行排序的功能。`Comparator`接口用于在**不修改对象类本身**的情况下，定义不同的排序逻辑。

### 基本结构

`Comparator`是一个泛型接口，其定义如下：

```java
public interface Comparator<T> {
    int compare(T o1, T o2);
}
```

**抽象方法：**

- **`int compare(T o1, T o2)`**: 这是`Comparator`接口中的唯一抽象方法。它接收两个对象作为参数，返回一个整数来表示比较的结果：
    - 返回负整数：如果第一个参数小于第二个参数。
    - 返回零：如果两个参数相等。
    - 返回正整数：如果第一个参数大于第二个参数。

### 使用方式

**说明：**

- `List`集合构造器不能传入比较器
- `List`类排序使用`Collections.sort(List,Comparator)`方法和`List.sort(Comparator)`方法进行比较，底层都是用`Arrays.sort()`方法。
- `Set`集合无序，通常不支持排序，但`TreeSet`和`LinkedHashSet`例外。
- `TreeSet`和`TreeMap`需要给构造器传入比较器。
- `LinkedHashSet`和`LinkedHashMap`维护了插入顺序，但不直接支持排序，需要将元素拷贝到可排序集合，再将结果存储到`LinkedHashSet`和`LinkedHashMap`中。

**方式：**

1. 使用匿名内部类
    
    - 不需要单独定义一个类来实现`Comparator`，可以直接在排序时使用匿名内部类。
    
    ```java
    import java.util.*;
    
    public class Main {
        public static void main(String[] args) {
            List<Person> people = new ArrayList<>();
            people.add(new Person("Alice", 30));
            people.add(new Person("Bob", 25));
            people.add(new Person("Charlie", 35));
    
            // 使用匿名内部类实现Comparator
            Collections.sort(people, new Comparator<Person>() {
                @Override
                public int compare(Person p1, Person p2) {
                    return Integer.compare(p1.age, p2.age);
                }
            });
    
            System.out.println(people); // 输出：[Bob (25), Alice (30), Charlie (35)]
        }
    }
    ```
    
2. 使用Lambda表达式
    
    - 使用Lambda表达式对匿名内部类进行简化。
    
    ```java
    import java.util.*;
    
    public class Main {
        public static void main(String[] args) {
            List<Person> people = new ArrayList<>();
            people.add(new Person("Alice", 30));
            people.add(new Person("Bob", 25));
            people.add(new Person("Charlie", 35));
    
            // 使用Lambda表达式实现Comparator
            people.sort((p1, p2) -> Integer.compare(p1.age, p2.age));
            System.out.println(people); // 输出：[Bob (25), Alice (30), Charlie (35)]
        }
    }
    ```
    
3. 使用方法引用
    
    - 使用方法引用使代码更简洁
    
    ```java
    import java.util.*;
    
    public class Main {
        public static void main(String[] args) {
            List<Person> people = new ArrayList<>();
            people.add(new Person("Alice", 30));
            people.add(new Person("Bob", 25));
            people.add(new Person("Charlie", 35));
    
            // 使用Comparator.comparing和方法引用
            people.sort(Comparator.comparingInt(Person::getAge));
            System.out.println(people); // 输出：[Bob (25), Alice (30), Charlie (35)]
        }
    }
    ```
    

### 默认方法

Java 8引入了一些默认方法来增强`Comparator`的功能，这些方法可以用于创建更复杂的比较逻辑：

- **`comparingInt()`**：返回一个比较器，对`int`类型按升序进行排序。
- **`reversed()`**：返回一个比较器，它反转当前比较器的排序顺序。
- **`thenComparing(Comparator<? super T> other)`**：用于链式比较。如果第一个比较器结果相等，使用第二个比较器进行比较。
- **`thenComparing(Function<? super T, ? extends U> keyExtractor)`**：根据提取的键的自然顺序进行比较。
- **`naturalOrder()`**：返回一个比较器，它使用`Comparable`接口的自然顺序。
- **`reverseOrder()`**：返回一个比较器，它使用`Comparable`接口的逆自然顺序。
- **`nullsFirst(Comparator<? super T> comparator)`**：返回一个比较器，它首先考虑`null`值。
- **`nullsLast(Comparator<? super T> comparator)`**：返回一个比较器，它最后考虑`null`值。

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person("Alice", 30));
        people.add(new Person("Bob", 25));
        people.add(new Person("Alice", 25));
        people.add(new Person("Charlie", 35));

        // 使用thenComparing进行链式排序：先按年龄升序，再按名称升序
        people.sort(Comparator.comparingInt((Person p) -> p.age)
                              .thenComparing(p -> p.name));
        System.out.println(people); 
        // 输出：[Alice (25), Bob (25), Alice (30), Charlie (35)]

        // 反转排序顺序：按年龄降序，再按名称降序
        people.sort(Comparator.comparingInt((Person p) -> p.age)
                              .reversed()
                              .thenComparing(p -> p.name).reversed());
        System.out.println(people); 
        // 输出：[Charlie (35), Alice (30), Bob (25), Alice (25)]
    }
}
```

## `Comparable`接口

`Comparable`接口是Java中用于定义对象**自然排序**（Natural Ordering）的一种接口。它允许类的实例进行彼此比较，从而可以对它们进行排序。

### 基本结构

`Comparable`接口位于`java.lang`包中，接口定义如下：

```java
public interface Comparable<T> {
    int compareTo(T o);
}
```

**抽象方法：**

- **`int compareTo(T o)`**: 这是`Comparable`接口的唯一抽象方法，用于比较当前对象与指定对象的顺序。返回一个整数来表示比较结果：
    - 返回负整数：当前对象小于指定对象。
    - 返回零：当前对象等于指定对象。
    - 返回正整数：当前对象大于指定对象。

### 使用方法

- 要使用`Comparable`接口，必须在类定义中实现`Comparable`接口。
- 重写`Comparable`接口的唯一抽象方法，提供对象之间的比较逻辑。
- `Collections.sort(people)`方法将使用`compareTo`方法对元素列表进行排序。
- `TreeSet`和`TreeMap`依赖于对象的自然顺序来维护元素的排序。因此，当使用这些集合时，如果对象没有提供自定义的`Comparator`，它们将依赖于对象的`compareTo`方法（不需要其它操作，直接就会排序好）。
- `compareTo`方法的实现应与`equals`方法一致，否则将导致某些集合错误行为。

```java
import java.util.*;

class Person implements Comparable<Person> {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Person other) {
        return Integer.compare(this.age, other.age);
    }

    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

public class Main {
    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person("Alice", 30));
        people.add(new Person("Bob", 25));
        people.add(new Person("Charlie", 35));

        // Collections.sort使用Person类的compareTo方法进行排序
        Collections.sort(people);

        System.out.println(people); // 输出：[Bob (25), Alice (30), Charlie (35)]
    }
}
```

## `Stream`流

利用Java 8引入的`Stream` API，可以对集合（如`List`、`Set`）进行排序，并以更简洁和流式的方式操作数据，本质上没有区别。`Stream`流的排序操作主要由`sorted`方法提供，该方法返回一个新的有序流。

### 排序方法

`Stream`接口提供了两种`sorted`方法用于排序：

1. **`sorted()`**：根据元素的自然顺序（需要实现`Comparable`接口）对流进行排序。
2. **`sorted(Comparator<? super T> comparator)`**：根据指定的`Comparator`对流进行排序，适用于定制排序。

### 使用方法

1. 使用自然排序
    
    ```java
    import java.util.*;
    import java.util.stream.Collectors;
    
    public class Main {
        public static void main(String[] args) {
            List<Person> people = Arrays.asList(
                new Person("Alice", 30),
                new Person("Bob", 25),
                new Person("Charlie", 35)
            );
    
            // 按自然顺序排序（假设Person实现了Comparable接口）
            List<Person> sortedPeople = people.stream()
                                              .sorted()  // 使用自然顺序
                                              .collect(Collectors.toList());
            System.out.println(sortedPeople); 
            // 输出：[Bob (25), Alice (30), Charlie (35)]
        }
    }
    ```
    
2. 使用`Comparator`进行定制排序
    
    ```java
    import java.util.*;
    import java.util.stream.Collectors;
    
    public class Main {
        public static void main(String[] args) {
            List<Person> people = Arrays.asList(
                new Person("Alice", 30),
                new Person("Bob", 25),
                new Person("Charlie", 35)
            );
    
            // 按年龄排序
            List<Person> sortedPeople = people.stream()
                                              .sorted(Comparator.comparingInt(person -> person.age))
                                              .collect(Collectors.toList());
            System.out.println(sortedPeople); 
            // 输出：[Bob (25), Alice (30), Charlie (35)]
        }
    }
    ```
    
3. 使用`Comparator`进行多重排序
    
    ```java
    import java.util.*;
    import java.util.stream.Collectors;
    
    public class Main {
        public static void main(String[] args) {
            List<Person> people = Arrays.asList(
                new Person("Alice", 30),
                new Person("Bob", 30),
                new Person("Charlie", 35)
            );
    
            // 先按年龄排序，再按名字排序
            List<Person> sortedPeople = people.stream()
                                              .sorted(Comparator.comparingInt((Person person) -> person.age)
                                                                .thenComparing(person -> person.name))
                                              .collect(Collectors.toList());
            System.out.println(sortedPeople); 
            // 输出：[Alice (30), Bob (30), Charlie (35)]
        }
    }
    ```
    

# Properties

在项目中获取 Properties 配置文件的几种方式


5ffa9e5868f79c9a


