# 1.Java 日志体系

## 1.1 体系概述

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671341706005-091d02ab-6115-4a63-a53a-35d035b40d0c.png#averageHue=%23fbf4f1&clientId=ucd3a413c-83cc-4&from=paste&height=426&id=u1afa9256&originHeight=426&originWidth=1010&originalType=binary&ratio=1&rotation=0&showTitle=false&size=235847&status=done&style=none&taskId=ud0f145c1-588b-4efc-bb1d-e80999806ec&title=&width=1010)

image.png

### 1.1.1 日志接口

- `JCL`：Apache 基⾦会所属的项⽬，是⼀套 Java ⽇志接⼝，之前叫 Jakarta Commons Logging，后更名为 Commons Logging，简称 JCL。
- `SLF4J`：Simple Logging Facade for Java，缩写 Slf4j，是⼀套简易 Java ⽇志⻔⾯，只提供相关接⼝，和其他⽇志⼯具之间需要桥接。

### 1.1.2 日志实现

- `Log4j`：⾪属于 Apache 基⾦会的⼀套⽇志框架，现已不再维护
- `JUL`：JDK 中的⽇志⼯具，也称为 jdklog、jdk-logging，⾃ Java1.4 以来 sun 的官⽅提供。
- `Logback`：⼀个具体的⽇志实现框架，和 Slf4j 是同⼀个作者，性能很好
- `Log4j2`：Log4j 的升级版本，与 Log4j 变化很⼤，不兼容

## 1.2 日志发展史

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671592556661-a4be13f7-cb5d-4382-aae0-51e06be2e502.png#averageHue=%23fbfaf9&clientId=ua2b4bcad-d821-4&from=paste&height=239&id=ub603d1f8&originHeight=263&originWidth=1197&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100907&status=done&style=none&taskId=u7e5f05ba-a8e9-4fe3-8836-8895df24d6c&title=&width=1088.181794596113)

image.png

> 相关阅读： JAVA日志发展史 - 腾讯云开发者社区-腾讯云

# 2.JUL

JUL 全称 `Java util Logging` 是 java 原生的日志框架，**使用时不需要另外引用第三方类库**，相对其他日志框架使用方便，学习简单，能够在小型应用中灵活使用。

## 2.1 JUL 入门

### 2.1.1 架构介绍

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671346350594-70d68ab4-bb05-4ed9-8508-6b26bbc6b9a5.png#averageHue=%23f7dece&clientId=ucd3a413c-83cc-4&from=paste&height=258&id=ue7e63878&originHeight=258&originWidth=806&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19599&status=done&style=none&taskId=u87d55107-9b1c-4c32-b1f3-460d8d7a7b9&title=&width=806)

image.png

- **Loggers**：被称为记录器，应用程序通过获取 Logger 对象，调用其 API 来来发布日志信息。Logger 通常是应用程序访问日志系统的入口程序。
- **Appenders**：也被称为 **Handlers**，每个 Logger 都会关联一组 Handlers，Logger 会将日志交给关联 Handlers 处理，由 Handlers 负责将日志做记录。Handlers 在此是一个抽象，其具体的实现决定了日志记录的位置可以是控制台、文件、网络上的其他日志服务或操作系统日志等。
- **Layouts**：也被称为 **Formatters**，它负责对日志事件中的数据进行转换和格式化。Layouts 决定了数据在一条日志记录中的最终形式。
- **Level**：每条日志消息都有一个关联的日志级别。该级别粗略指导了日志消息的重要性和紧迫，我可以将 Level 和 Loggers，Appenders 做关联以便于我们过滤消息。
- **Filters**：过滤器，根据需要定制哪些信息会被记录，哪些信息会被放过。

总结一下过程： **用户使用 Logger 来进行日志记录，Logger 持有若干个 Handler，日志的输出操作是由 Handler 完成的。在 Handler 在输出日志前，会经过 Filter 的过滤，判断哪些日志级别过滤放行哪些拦截，Handler 会将日志内容输出到指定位置（日志文件、控制台等）。Handler 在输出日志时会使用 Layout，将输出内容进行排版。**

### 2.1.2 入门案例

```java
public class JULTest {    @Test    public void test1(){        Logger logger = Logger.getLogger("JULTest");        logger.info("info1");        logger.log(Level.INFO,"info2");        String name = "张三";        int age = 12;        logger.log(Level.INFO,"用户信息：{0},{1}",new Object[]{name, age});    }}
```

## 2.2 日志级别

`java.util.logging.Level` 中定义了日志的级别：

- `SEVERE`—-> 最高级别
- `WARNING`
- `INFO`—-> 默认级别
- `CONFIG`
- `FINE`
- `FINER`
- `FINEST`—-> 最低级别

两个特殊的级别：

- `OFF`，可用来关闭日志记录。
- `ALL`，启用所有消息的日志记录。

默认情况下，一个 logger 只实现 info 以上的级别 测

```java
@Test
public void test2(){
Logger logger = Logger.getLogger(“JULTest”);
logger.severe(“severe”);
logger.warning(“warning”);
logger.info(“info”);
logger.config(“config”);
logger.fine(“fine”);
logger.finer(“finer”);
logger.finest(“finest”);
}

```

输出： ![image.png](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671348841676-3178699a-d77f-4601-b206-d49dd2786fd9.png#averageHue=%23282c34&clientId=ucd3a413c-83cc-4&from=paste&height=174&id=u88678a1f&originHeight=191&originWidth=611&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22597&status=done&style=none&taskId=u77de8f9d-02b0-4a9a-ac22-a6101e90429&title=&width=555.4545334153927) 可以自定义设置 Logger 的输出级别 自定义 Logger```java @Test public void test3() throws IOException { // 1. 创建 Logger 对象 Logger logger = Logger.getLogger("JULTest"); // 2. 自定义 Logger 的日志级别 // a. 关闭用户父 Handler logger.setUseParentHandlers(false); // b. 创建新的 handler 对象（输出控制台） ConsoleHandler handler = new ConsoleHandler(); // c. 创建新的 formatter 对象 SimpleFormatter formatter = new SimpleFormatter(); // d. 将 Logger、Handler、Formatter关联 handler.setFormatter(formatter); logger.addHandler(handler); // e. 同时设置 Logger 和 Handler 的级别 logger.setLevel(Level.ALL); handler.setLevel(Level.ALL);

```
// 输出到日志文件
FileHandler fileHandler = new FileHandler("E:/JUL.log");
fileHandler.setFormatter(formatter);
logger.addHandler(fileHandler);

logger.severe("severe");
logger.warning("warning");
logger.info("info");
logger.config("config");
logger.fine("fine");
logger.finer("finer");
logger.finest("finest");
```

}

````

代理解释：

1. 首先需要关闭 Logger 对象的父 Handler
2. 创建自定义的 handler、formatter，并且将三者关联
3. 对于 ConsoleHandler 必须同时设置 Logger 和 Handler 的级别，并且以两者的最高级别为输出级别
4. 对于 FileHandler 是以 Logger 的日志级别为准，不需要再设置 FileHandler 的日志级别

## 2.3 Logger 父子关系

JUL 中 Logger 之间存在父子关系，这种父子关系通过**树状结构**存储，JUL 在初始化时会创建一个顶层 `RootLogger`（名字为空字符串） 作为所有 Logger 父 Logger，存储上作为树状结构的根节点。**父子关系通过路径来关联**。

```java
@Testpublic void test4(){    Logger logger1 = Logger.getLogger("com.dong.JULTest");    Logger logger2 = Logger.getLogger("com.dong");    // logger1 的父对象    System.out.println(logger1.getParent().getClass()+":"+logger1.getParent().getName());    // logger2 的父对象    System.out.println(logger2.getParent().getClass()+":"+logger2.getParent().getName());    // 自定义 logger2 的日志级别    logger2.setUseParentHandlers(false);    ConsoleHandler consoleHandler = new ConsoleHandler();    SimpleFormatter simpleFormatter = new SimpleFormatter();    consoleHandler.setFormatter(simpleFormatter);    logger2.addHandler(consoleHandler);    logger2.setLevel(Level.ALL);    consoleHandler.setLevel(Level.ALL);    // 对 logger1 进行测试    logger1.severe("severe");    logger1.warning("warning");    logger1.info("info");    logger1.config("config");    logger1.fine("fine");    logger1.finer("finer");    logger1.finest("finest");}
````

输出：

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671351733855-3add35f7-45d5-48c6-9fe5-92c6570488dd.png#averageHue=%23282c35&clientId=ucd3a413c-83cc-4&from=paste&height=482&id=u720ab375&originHeight=530&originWidth=638&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60304&status=done&style=none&taskId=uca1e6da8-4e30-4237-8596-cd2f674a4fa&title=&width=579.9999874288388)

image.png

在上面代码中，我们看到 logger1 和 logger2 是父子关系，我们自定义了 logger2 的日志级别，但因为 logger1 继承自 logger2，所以 logger1 具有和 logger2 一样的日志级别。

## 2.4 日志的配置文件

默认配置文件路径 `$JAVAHOME\\jre\\lib\\logging.properties`，LogManager 默认加载的是这一份配置文件。 我们可以设置加载自定义自定义配置文件。将路径下的配置文件拷贝一份，复制到 resources 目录下，在代码中设置不加载默认配置文件，而是加载自定义的配置文件。

```java
@Testpublic void test5() throws IOException {    // 加载自定义配置文件    InputStream inputStream = JULTest.class.getClassLoader().getResourceAsStream("logging.properties");    // 创建 LogManager 对象    LogManager logManager = LogManager.getLogManager();    // LogManager 加载配置文件    logManager.readConfiguration(inputStream);    // 测试日志的输出    Logger logger = Logger.getLogger("JULTest");    logger.severe("severe");    logger.warning("warning");    logger.info("info");    logger.config("config");    logger.fine("fine");    logger.finer("finer");    logger.finest("finest");}
```

配置文件（logging.properties）：

```
## RootLogger使用的处理器（获取时设置）
handlers= java.util.logging.ConsoleHandler
# RootLogger日志等级
.level=FINEST
## 自定义Logger
com.dong.handlers= java.util.logging.FileHandler
# 自定义Logger日志等级
com.dong.level= INFO
# 忽略父日志设置
com.dong.useParentHandlers=false
## 控制台处理器
# 输出日志级别
java.util.logging.ConsoleHandler.level = FINEST
# 输出日志格式
java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter
## 文件处理器
# 输出日志级别
java.util.logging.FileHandler.level=INFO
# 输出日志格式
java.util.logging.FileHandler.formatter = java.util.logging.SimpleFormatter
# 输出日志文件路径
java.util.logging.FileHandler.pattern = /java%u.log
# 输出日志文件限制大小（50000字节）
java.util.logging.FileHandler.limit = 50000
# 输出日志文件限制个数
java.util.logging.FileHandler.count = 10
# 输出日志文件 是否是追加
java.util.logging.FileHandler.append=true
```

输出：

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671353108334-db6a8421-af5b-4e3a-ba82-ce0545346dd0.png#averageHue=%23282c34&clientId=ucd3a413c-83cc-4&from=paste&height=417&id=u21d0202d&originHeight=459&originWidth=635&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53405&status=done&style=none&taskId=u75f3c33b-4a60-4521-9ea1-8d710e50e15&title=&width=577.2727147606781)

image.png

## 2.5 日志原理解析

1. 初始化 LogManager
    1. LogManager 加载 logging.properties 配置
    2. 添加 Logger 到 LogManager
2. 从单例 LogManager 获取 Logger
3. 设置级别 Level，并指定日志记录 LogRecord
4. Filter 提供了日志级别之外更细粒度的控制
5. Handler 是用来处理日志输出位置
6. Formatter 是用来格式化 LogRecord 的

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671353666764-c9e0f5b9-30a2-4ce8-a171-639552e5084d.png#averageHue=%23f9f6f3&clientId=ucd3a413c-83cc-4&from=paste&height=211&id=ua68cce9e&originHeight=232&originWidth=947&originalType=binary&ratio=1&rotation=0&showTitle=false&size=85048&status=done&style=none&taskId=ue5cb284e-f620-4df4-9ee7-1c343441ed0&title=&width=860.9090722493893)

image.png

# 3.Log4j

Log4j 由 Ceki 开发并捐献给了 Apache。通过在项目中使用 Log4J，我们可以控制日志信息输出到控制台、文件、甚至是数据库中。我们可以控制每一条日志的输出格式，通过定义日志的输出级别，可以更灵活的控制日志的输出过程。方便项目的调试。

## 3.1 Log4j 入门

需要先添加 Log4j 的依赖

```xml
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
```

代码：

```java
@Testpublic void test1(){    // 初始化系统配置，不需要配置文件    BasicConfigurator.configure();    Logger logger = Logger.getLogger("Log4jTest");    logger.info("info1");    logger.log(Level.INFO, "info2");}
```

因为没有添加配置文件，所以在代码中初始化系统配置`BasicConfigurator.configure();`用于初始化 RootLogger 和 Appends 日志级别： `org.apache.log4j.Level` 中定义了日志级别：

- fatal：指出每个严重的错误事件将会导致应用程序的退出。
- error：指出虽然发生错误事件，但仍然不影响系统的继续运行。
- warn：表明会出现潜在的错误情形。
- info：一般和在粗粒度级别上，强调应用程序的运行全程。
- debug：一般用于细粒度级别上，对调试应用程序非常有帮助。
- trace：是程序追踪，可以用于输出程序运行中的变量，显示执行的流程。

还有两个特殊的级别：

- OFF，可用来关闭日志记录。
- ALL，启用所有消息的日志记录。

## 3.2 Log4j 组件

Log4J 主要由 Loggers (日志记录器)、Appenders（输出端）和 Layout（日志格式化器）组成。其中 Loggers 控制日志的输出级别与日志是否输出；Appenders 指定日志的输出方式（输出到控制台、文件等）；Layout 控制日志信息的输出格式。

### 3.2.1 Loggers

日志记录器，负责收集处理日志记录，实例的命名就是类“XX”的 full quailied name（类的全限定名），Logger 的名字大小写敏感，其命名有继承机制，例如：name 为 org.apache.commons 的 logger 会继承 name 为 org.apache 的 logger。 Log4J 中有一个特殊的 logger 叫做“root”，他是所有 logger 的根，也就意味着其他所有的 logger 都会直接或者间接地继承自 root。root logger 可以用 Logger.getRootLogger() 方法获取。 但是，自 log4j 1.2 版以来， Logger 类已经取代了 Category 类。对于熟悉早期版本的 log4j 的人来说，Logger 类可以被视为 Category 类的别名。

### 3.2.2 Appenders

Appender 用来指定日志输出到哪个地方，可以同时指定日志的输出目的地。Log4j 常用的输出目的地有以下几种：

|​**输出端类型**|​**作用**|
|---|---|
|ConsoleAppender|将日志输出到控制台|
|FileAppender|将日志输出到文件中|
|DailyRollingFileAppender|将日志输出到一个日志文件，并且每天输出到一个新的文件|
|RollingFileAppender|将日志信息输出到一个日志文件，并且指定文件的尺寸，当文件大小达|
|到指定尺寸时，会自动把文件改名，同时产生一个新的文件|把日志信息保存到数据库中|
|JDBCAppender||

### 3.2.3 Layouts

布局器 Layouts用于控制日志输出内容的格式，让我们可以使用各种需要的格式输出日志。Log4j常用的Layouts：

|​**格式化器类型**|​**作用**|
|---|---|
|HTMLLayout|格式化日志输出为HTML表格形式|
|SimpleLayout|简单的日志输出格式化，打印的日志格式为（info - message）|
|PatternLayout|最强大的格式化期，可以根据自定义格式输出日志，如果没有指定转换格式，就是用默认的转换格式|

## 3.3 Layout的格式

在 log4j.properties 配置文件中，我们定义了日志输出级别与输出端，在输出端中分别配置日志的输出格式。

```markdown
* log4j 采用类似 C 语言的 printf 函数的打印格式格式化日志信息，具体的占位符及其含义如下：
    %m 输出代码中指定的日志信息
    %p 输出优先级，及 DEBUG、INFO 等
    %n 换行符（Windows平台的换行符为 "\\n"，Unix 平台为 "\\n"）
    %r 输出自应用启动到输出该 log 信息耗费的毫秒数
    %c 输出打印语句所属的类的全名
    %t 输出产生该日志的线程全名
    %d 输出服务器当前时间，默认为 ISO8601，也可以指定格式，如：%d{yyyy年MM月dd日HH:mm:ss}
    %l 输出日志时间发生的位置，包括类名、线程、及在代码中的行数。如：Test.main(Test.java:10)
    %F 输出日志消息产生时所在的文件名称
    %L 输出代码中的行号
    %% 输出一个 "%" 字符
* 可以在 % 与字符之间加上修饰符来控制最小宽度、最大宽度和文本的对其方式。如：
        %5c 输出category名称，最小宽度是5，category<5，默认的情况下右对齐
    %-5c 输出category名称，最小宽度是5，category<5，"-"号指定左对齐,会有空格
    %.5c 输出category名称，最大宽度是5，category>5，就会将左边多出的字符截掉，<5不会有空格
    %20.30c category名称<20补空格，并且右对齐，>30字符，就从左边交远销出的字符截掉
```

## 3.4 Appender的输出

log4j.properties：

```
#指定日志的输出级别与输出端
log4j.rootLogger=trace,Console
# 控制台输出配置
log4j.appender.Console=org.apache.log4j.ConsoleAppender
log4j.appender.Console.layout=org.apache.log4j.PatternLayout
log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n
# 文件输出配置
log4j.appender.file = org.apache.log4j.DailyRollingFileAppender
#指定日志的输出路径
log4j.appender.file.file = D:/log.txt
log4j.appender.file.append = true
#使用自定义日志格式化器
log4j.appender.file.layout = org.apache.log4j.PatternLayout
#指定日志的输出格式
log4j.appender.file.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} [%t:%r] - [%p] %m%n
#指定日志的文件编码
log4j.appender.file.encoding=UTF-8
#mysql
log4j.appender.logDB=org.apache.log4j.jdbc.JDBCAppender
log4j.appender.logDB.layout=org.apache.log4j.PatternLayout
log4j.appender.logDB.Driver=com.mysql.jdbc.Driver
log4j.appender.logDB.URL=jdbc:mysql://localhost:3306/test
log4j.appender.logDB.User=root
log4j.appender.logDB.Password=root
log4j.appender.logDB.Sql=INSERT INTO log(project_name,create_date,level,category,file_name,thread_name,line,all_category,message) values('itcast','%d{yyyy-MM-ddHH:mm:ss}','%p','%c','%F','%t','%L','%l','%m')
```

数据库参数：

```sql
CREATE TABLE `log` (
`log_id` int(11) NOT NULL AUTO_INCREMENT,
`project_name` varchar(255) DEFAULT NULL COMMENT '目项名',
`create_date` varchar(255) DEFAULT NULL COMMENT '创建时间',
`level` varchar(255) DEFAULT NULL COMMENT '优先级',
`category` varchar(255) DEFAULT NULL COMMENT '所在类的全名',
`file_name` varchar(255) DEFAULT NULL COMMENT '输出日志消息产生时所在的文件名称 ',
`thread_name` varchar(255) DEFAULT NULL COMMENT '日志事件的线程名',
`line` varchar(255) DEFAULT NULL COMMENT '号行',
`all_category` varchar(255) DEFAULT NULL COMMENT '日志事件的发生位置',
`message` varchar(4000) DEFAULT NULL COMMENT '输出代码中指定的消息',
PRIMARY KEY (`log_id`)
);
```

## 3.5 自定义 Logger

在配置文件中添加 `log4j.logger.`用于指定自定义 Logger

```
# RootLogger配置
log4j.rootLogger = trace,console
# 自定义Logger
log4j.logger.com.dong = info,console
log4j.logger.org.apache = error
```

在这里设置 com.dong 的自定义 Logger，因为 com.dong.Log4jTest 继承自 com.dong，所以同样遵循上面的规则，而 logger 因为没有指定 Appender，所以默认使用 RootLogger 的配置

```
@Test
public void test3(){
    Logger logger1 = Logger.getLogger(Log4jTest.class);
    Logger logger2 = Logger.getLogger(Logger.class);
    logger1.fatal("fatal1");
    logger1.error("error1");
    logger1.warn("warn1");
    logger1.info("info1");
    logger1.debug("debug1");
    logger1.trace("trace1");
    logger2.fatal("fatal2");
    logger2.error("error2");
    logger2.warn("warn2");
    logger2.info("info2");
    logger2.debug("debug2");
    logger2.trace("trace2");
}
```

# 4.JCL

全称为Jakarta Commons Logging，是Apache提供的一个通用日志API。 它是为 “所有的Java日志实现”提供一个统一的接口，它自身也提供一个日志的实现，但是功能非常常弱（SimpleLog）。所以一般不会单独使用它。他允许开发人员使用不同的具体日志实现工具: Log4j, Jdk 自带的日志（JUL) JCL 有两个基本的抽象类：Log(基本记录器)和LogFactory(负责创建Log实例)。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671513435783-e6007119-bbbb-4c18-95b3-880596d809ea.png#averageHue=%23fbfbfb&clientId=ua2b4bcad-d821-4&from=paste&height=386&id=ub281359a&originHeight=425&originWidth=818&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65102&status=done&style=none&taskId=ufaced751-496c-4d26-b631-1eb1db69d28&title=&width=743.6363475184799)

image.png

## 4.1 JCL入门

添加依赖：

```xml
<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging</artifactId>
    <version>1.2</version>
</dependency>
```

代码：

```java
@Testpublic void test1(){    Log log = LogFactory.getLog(JCLTest.class);    log.fatal("fatal");    log.error("error");    log.warn("warn");    log.info("info");    log.debug("debug");}
```

## 4.2 JCL 原理

1. 通过LogFactory动态加载Log实现类
    
    ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671514381920-2303a7ba-53a1-4e78-bad9-81e4f5a729c5.png#averageHue=%23f9f9f9&clientId=ua2b4bcad-d821-4&from=paste&height=183&id=u75b2a2f8&originHeight=201&originWidth=1254&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13289&status=done&style=none&taskId=u2c44cdad-48a5-48a4-b893-6dfa35b55e5&title=&width=1139.999975291166)
    
    image.png
    
2. 日志门面支持的日志实现数组
    

```java
private static final String[] classesToDiscover =
    new String[]{"org.apache.commons.logging.impl.Log4JLogger",                 "org.apache.commons.logging.impl.Jdk14Logger",                 "org.apache.commons.logging.impl.Jdk13LumberjackLogger",                 "org.apache.commons.logging.impl.SimpleLog"};
```

1. 获取具体的日志实现

```java
for(int i = 0; i < classesToDiscover.length && result == null; ++i) {    result = this.createLogFromClass(classesToDiscover[i], logCategory,true);}
```

相关阅读： [https://bbs.huaweicloud.com/blogs/384493](https://bbs.huaweicloud.com/blogs/384493)

# 5.SLF4J⭐

简单日志门面（Simple Logging Facade For Java) SLF4J 主要是为了给 Java 日志访问提供一套标准、规范的 API 框架，**其主要意义在于提供接口**，**具体的实现可以交由其他日志框架**，例如 log4j 和 logback 等。当然 slf4j 自己也提供了功能较为简单的实现，但是一般很少用到。对于一般的 Java 项目而言，日志框架会选择 slf4j-api 作为门面，配上具体的实现框架（log4j、logback等），中间使用桥接器完成桥接。 SLF4J 是目前市面上最流行的日志门面。现在的项目中，基本上都是使用 SLF4J 作为我们的日志系统。 SLF4J 日志门面主要提供两大功能：

1. 日志框架的绑定
2. 日志框架的桥接

## 5.1 SLF4J 入门

添加依赖：

```xml
<!--slf4j 门面--><dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.25</version>
</dependency>
<!--slf4j 自带的简单实现--><dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-simple</artifactId>
    <version>1.7.25</version>
</dependency>
```

代码：

```java
@Testpublic void test1(){    // 获取日志记录器    Logger logger = LoggerFactory.getLogger(Slf4jTest.class);    // 打印    logger.error("error");    logger.warn("warn");    logger.info("info");    logger.debug("debug");    logger.trace("trace");    // 使用占位符，将程序信息输出到日志    String name = "张三";    int age = 20;    logger.info("用户信息：{}，{}",name, age);    // 将异常输出到日志    try {        int number = 1 / 0;    } catch (Exception e) {        logger.error("出现异常：",e);    }}
```

**注意：门面与实现版本一致。**

## 5.2 绑定日志实现

SLF4J 发行版附带了几个称为“SLF4J绑定”的jar文件，每个绑定对应一个受支持的框架。 使用 slf4j 的日志绑定流程：

1. 添加 slf4j-api 的依赖
2. 使用 slf4j 的 API 在项目中进行统一的日志记录
3. 绑定具体的日志实现框架
    1. 绑定已经实现了 slf4j 的日志框架，直接添加对应依赖（logback、simple、nop，因为出现的比 slf4j 晚，所以遵循 slf4j-api 规范）
    2. 绑定没有实现 slf4j 的日志框架，先添加日志的**适配器**，再添加实现类的依赖（log4j、JUL，因为出现的比较早，所以没有遵循 slf4j-api 规范）
4. slf4j 有且仅有一个日志实现框架的绑定（如果出现多个默认使用第一个依赖日志实现）

添加依赖（常用日志实现框架）：

```xml
<!--slf4j门面，必须添加--><dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.25</version>
</dependency>
<!--slf4j自带的简单实现(选择或者注释)--><dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-simple</artifactId>
    <version>1.7.25</version>
</dependency>
<!-- log4j 适配器--><dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-log4j12</artifactId>
    <version>1.7.25</version>
</dependency>
<!-- log4j--><dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
<!-- jul 因为自带，只需导入适配器--><dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-jdk14</artifactId>
    <version>1.7.25</version>
</dependency>
<!--jcl --><dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-jcl</artifactId>
    <version>1.7.25</version>
</dependency>
<!-- nop --><dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-nop</artifactId>
    <version>1.7.25</version>
</dependency>
```

要切换日志框架，只需替换类路径上的 slf4j 绑定。例如，要从 JUL 切换到 log4j，只需将 slf4j-jdk14-1.7.27.jar 替换为 slf4j-log4j12-1.7.27.jar 即可（对于旧的日志框架）。 SLF4J 不依赖于任何特殊的类装载。实际上，每个 SLF4J 绑定在编译时都是硬连线的， 以使用一个且只有一个特定的日志记录框架。例如，slf4j-log4j12-1.7.27.jar 绑定在编译时绑定以使用 log4j。在代码中，除了 slf4j-api-1.7.27.jar 之外，只需选择一个且只有一个绑定放到相应的类路径位置。不要在类路径上放置多个绑定。以下是一般概念的图解说明。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671517966128-e3d232e4-b814-405f-a06b-be478463c7a8.png#averageHue=%23dddcdb&clientId=ua2b4bcad-d821-4&from=paste&height=729&id=ufb417aba&originHeight=802&originWidth=1267&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60325&status=done&style=none&taskId=u7d4bbd61-471e-4c64-83eb-ec7e7f3b9ae&title=&width=1151.8181568531957)

image.png

其中 slf4j-nop 为 slf4j 日志门面的开关，一旦导入这个 jar 包，slf4j 将不会进行日志的记录。

## 5.3 桥接旧的日志实现

通常，代码中某些组件依赖于 SLF4J 以外的日志记录 API。也可以假设这些组件在不久的将来不会切换到 SLF4J。为了解决这种情况，SLF4J 附带了几个桥接模块，这些模块将对 log4j，JCL 和 java.util.logging API 的调用重定向，就好像它们是对 SLF4J API 一样。 **桥接解决的是项目中日志的遗留问题**，当系统中存在之前的日志 API，可以通过桥接转换到 slf4j 的实现

1. 先去除之前老的日志框架的依赖
2. 添加 SLF4J 提供的桥接组件
3. 为项目添加 SLF4J 的具体实现

**迁移的方式：** 如果我们要使用 SLF4J 的桥接器，替换原有的日志框架，那么我们需要做的第一件事情，就是删除掉原有项目中的日志框架的依赖。然后替换成 SLF4J 提供的桥接器。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671518146153-286b8c83-0ed7-4709-b1f2-9e48f36cacc4.png#averageHue=%23f6f5f4&clientId=ua2b4bcad-d821-4&from=paste&height=845&id=ua5d98ab4&originHeight=930&originWidth=1316&originalType=binary&ratio=1&rotation=0&showTitle=false&size=323155&status=done&style=none&taskId=u6c0fec13-0ada-4a64-b634-67f4af08c26&title=&width=1196.3636104331536)

image.png

```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>log4j-over-slf4j</artifactId>
    <version>1.7.25</version>
</dependency>
<!-- jul --><dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>jul-to-slf4j</artifactId>
    <version>1.7.25</version>
</dependency>
<!--jcl --><dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>jcl-over-slf4j</artifactId>
    <version>1.7.25</version>
</dependency>
```

注意：

1. `jcl-over-slf4j.jar` 和 `slf4j-jcl.jar`不能同时部署。前一个 jar 文件将导致 JCL 将日志系统的选择委托给 SLF4J，后一个 jar 文件将导致SLF4J 将 JCL 作为日志的实现，从而导致无限循环。
2. `log4j-over-slf4j.jar` 和 `slf4j-log4j12.jar` 不能同时出现
3. `jul-to-slf4j.jar` 和 `slf4j-jdk14.jar` 不能同时出现
4. 所有的桥接都只对 Logger 日志记录器对象有效，如果程序中调用了内部的配置类或者是 Appender、Filter 等对象，将无法产生效果。

## 5.4 SLF4J原理

1. SLF4J 通过 LoggerFactory 加载日志具体的实现对象。
2. LoggerFactory 在初始化的过程中，会通过 `performInitialization()` 方法绑定具体的日志实现。
3. 在绑定具体实现的时候，通过类加载器，加载 `org/slf4j/impl/StaticLoggerBinder.class`
4. 所以，只要是一个日志实现框架，在 `org.slf4j.impl` 包中提供一个自己的 StaticLoggerBinder 类，在其中提供具体日志实现的 LoggerFactory就可以被 SLF4J 所加载

# 6.LogBack⭐

Logback 是由 log4j 创始人设计的另一个开源日志组件，性能比 log4j 要好。因为 log4j 爆出存在安全漏洞，所以现在推荐使用 logback Logback 主要分为三个模块：

- logback-core：其它两个模块的基础模块
- logback-classic：它是 log4j 的一个改良版本，同时它完整实现了 slf4j API
- logback-access：访问模块与 Servlet 容器集成提供通过 Http 来访问日志的功能

后续的日志代码都是通过 SLF4J 日志门面搭建日志系统，所以在代码是没有区别，主要是通过修改配置文件和 pom.xml 依赖

## 6.1 LogBack 入门

添加依赖：

```xml
<!--slf4j-api--><dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.25</version>
</dependency>
<!--logback-classic--><dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.3</version>
</dependency>
```

代码：

```java
@Testpublic void test1(){    // 获取日志记录器    Logger logger = LoggerFactory.getLogger(Slf4jTest.class);    // 打印    logger.error("error");    logger.warn("warn");    logger.info("info");    logger.debug("debug");    logger.trace("trace");    // 使用占位符，将程序信息输出到日志    String name = "张三";    int age = 20;    logger.info("用户信息：{}，{}",name, age);    // 将异常输出到日志    try {        int number = 1 / 0;    } catch (Exception e) {        logger.error("出现异常：",e);    }}
```

## 6.2 LogBack配置

logback会依次读取以下类型配置文件：

- logback.groovy
- logback-test.xml
- logback.xml 如果均不存在会采用默认配置

logback组件之间的关系：

1. Logger:日志的记录器，把它关联到应用的对应的context上后，主要用于存放日志对象，也 可以定义日志类型、级别。
2. Appender:用于指定日志输出的目的地，目的地可以是控制台、文件、数据库等等。
3. Layout:负责把事件转换成字符串，格式化的日志信息的输出。在logback中Layout对象被封装在encoder中。

基本配置信息：

```xml
<?xml version="1.0" encoding="UTF-8"?><configuration>
    <!--    日志输出格式：    %-5level    %d{yyyy-MM-dd HH:mm:ss.SSS} 日期    %c 类的完整名称    %M 为method    %L 为行号    %thread 线程名称    %m或者%msg 为信息    %n 换行    -->    <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度,%msg：日志消息，%n是换行符-->    <property name="pattern" value="%d{yyyy-MM-dd HH:mm:ss.SSS} %c [%thread] %-5level %msg%n"/>
    <!--    Appender: 设置日志信息的去向,常用的有以下几个    ch.qos.logback.core.ConsoleAppender (控制台)    ch.qos.logback.core.rolling.RollingFileAppender (文件大小到达指定尺寸的时候产生一个新文件)    ch.qos.logback.core.FileAppender (文件)    -->    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <!--输出流对象 默认 System.out 改为 System.err-->        <target>System.err</target>
        <!--日志格式配置-->        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>${pattern}</pattern>
        </encoder>
    </appender>
    <!--    用来设置某一个包或者具体的某一个类的日志打印级别、以及指定<appender>。    <logger>仅有一个name属性，一个可选的level和一个可选的addtivity属性    name:    用来指定受此logger约束的某一个包或者具体的某一个类。    level:    用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和    OFF，    如果未设置此属性，那么当前logger将会继承上级的级别。    additivity:    是否向上级loger传递打印信息。默认是true。    <logger>可以包含零个或多个<appender-ref>元素，标识这个appender将会添加到这个    logger    -->    <!--    也是<logger>元素，但是它是根logger。默认debug    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL    和 OFF，    <root>可以包含零个或多个<appender-ref>元素，标识这个appender将会添加到这个    logger。    -->    <root level="ALL">
        <appender-ref ref="console"/>
    </root>
</configuration>
```

FileAppender配置：

```xml
<?xml version="1.0" encoding="UTF-8"?><configuration>
    <!-- 自定义属性 可以通过${name}进行引用-->    <property name="pattern" value="[%-5level] %d{yyyy-MM-dd HH:mm:ss} %c %M%L [%thread] %m %n"/>
    <!--    日志输出格式：    %d{pattern}日期    %m或者%msg为信息    %M为method    %L为行号    %c类的完整名称    %thread线程名称    %n换行    %-5level    -->    <!-- 日志文件存放目录 -->    <property name="log_dir" value="d:/logs"></property>
    <!--控制台输出appender对象-->    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <!--输出流对象 默认 System.out 改为 System.err-->        <target>System.err</target>
        <!--日志格式配置-->        <encoder                class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>${pattern}</pattern>
        </encoder>
    </appender>
    <!--日志文件输出appender对象-->    <appender name="file" class="ch.qos.logback.core.FileAppender">
        <!--日志格式配置-->        <encoder                class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>${pattern}</pattern>
        </encoder>
        <!--日志输出路径-->        <file>${log_dir}/logback.log</file>
    </appender>
    <!-- 生成html格式appender对象 -->    <appender name="htmlFile" class="ch.qos.logback.core.FileAppender">
        <!--日志格式配置-->        <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
            <layout class="ch.qos.logback.classic.html.HTMLLayout">
                <pattern>%level%d{yyyy-MM-dd
                    HH:mm:ss}%c%M%L%thread%m</pattern>
            </layout>
        </encoder>
        <!--日志输出路径-->        <file>${log_dir}/logback.html</file>
    </appender>
    <!--RootLogger对象-->    <root level="all">
        <appender-ref ref="console"/>
        <appender-ref ref="file"/>
        <appender-ref ref="htmlFile"/>
    </root>
</configuration>
```

RollingFileAppender配置：

```xml
<?xml version="1.0" encoding="UTF-8"?><configuration>
    <!-- 自定义属性 可以通过${name}进行引用-->    <property name="pattern" value="[%-5level] %d{yyyy-MM-dd HH:mm:ss} %c %M%L [%thread] %m %n"/>
    <!--    日志输出格式：    %d{pattern}日期    %m或者%msg为信息    %M为method    %L为行号    %c类的完整名称    %thread线程名称    %n换行    %-5level    -->    <!-- 日志文件存放目录 -->    <property name="log_dir" value="d:/logs"></property>
    <!--控制台输出appender对象-->    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <!--输出流对象 默认 System.out 改为 System.err-->        <target>System.err</target>
        <!--日志格式配置-->        <encoder                class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>${pattern}</pattern>
        </encoder>
    </appender>
    <!-- 日志文件拆分和归档的appender对象-->    <appender name="rollFile"              class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!--日志格式配置-->        <encoder                class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>${pattern}</pattern>
        </encoder>
        <!--日志输出路径-->        <file>${log_dir}/roll_logback.log</file>
        <!--指定日志文件拆分和压缩规则-->        <rollingPolicy                class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <!--通过指定压缩文件名称，来确定分割文件方式-->            <fileNamePattern>${log_dir}/rolling.%d{yyyy-MMdd}.log%i.gz</fileNamePattern>
            <!--文件拆分大小-->            <maxFileSize>1MB</maxFileSize>
        </rollingPolicy>
    </appender>
    <!--RootLogger对象-->    <root level="all">
        <appender-ref ref="console"/>
        <appender-ref ref="rollFile"/>
    </root>
</configuration>
```

Filter和异步日志配置：

```xml
<?xml version="1.0" encoding="UTF-8"?><configuration>
    <!-- 自定义属性 可以通过${name}进行引用-->    <property name="pattern" value="[%-5level] %d{yyyy-MM-dd HH:mm:ss} %c %M%L [%thread] %m %n"/>
    <!--    日志输出格式：    %d{pattern}日期    %m或者%msg为信息    %M为method    %L为行号    %c类的完整名称    %thread线程名称    %n换行    %-5level    -->    <!-- 日志文件存放目录 -->    <property name="log_dir" value="d:/logs/"></property>
    <!--控制台输出appender对象-->    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <!--输出流对象 默认 System.out 改为 System.err-->        <target>System.err</target>
        <!--日志格式配置-->        <encoder                class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>${pattern}</pattern>
        </encoder>
    </appender>
    <!-- 日志文件拆分和归档的appender对象-->    <appender name="rollFile"              class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!--日志格式配置-->        <encoder                class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>${pattern}</pattern>
        </encoder>
        <!--日志输出路径-->        <file>${log_dir}roll_logback.log</file>
        <!--指定日志文件拆分和压缩规则-->        <rollingPolicy                class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <!--通过指定压缩文件名称，来确定分割文件方式-->            <fileNamePattern>${log_dir}rolling.%d{yyyy-MMdd}.log%i.gz</fileNamePattern>
            <!--文件拆分大小-->            <maxFileSize>1MB</maxFileSize>
        </rollingPolicy>
        <!--filter配置-->        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <!--设置拦截日志级别-->            <level>error</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>
    <!--异步日志-->    <appender name="async" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="rollFile"/>
    </appender>
    <!--RootLogger对象-->    <root level="all">
        <appender-ref ref="console"/>
        <appender-ref ref="async"/>
    </root>
    <!--自定义logger additivity表示是否从 rootLogger继承配置-->    <logger name="com.itheima" level="debug" additivity="false">
        <appender-ref ref="console"/>
    </logger>
</configuration>
```

官方提供的log4j.properties转换成logback.xml [https://logback.qos.ch/translator/](https://logback.qos.ch/translator/)

## 6.3 logback-access的使用

logback-access模块与Servlet容器（如Tomcat和Jetty）集成，以提供HTTP访问日志功能。我们可以使用logback-access模块来替换tomcat的访问日志。

1. 将logback-access.jar与logback-core.jar复制到$TOMCAT_HOME/lib/目录下
2. 修改$TOMCAT_HOME/conf/server.xml中的Host元素中添加：

```xml
<Valve className="ch.qos.logback.access.tomcat.LogbackValve" />
```

1. logback默认会在$TOMCAT_HOME/conf下查找文件 logback-access.xml

```xml
<?xml version="1.0" encoding="UTF-8"?><configuration>
    <!-- always a good activate OnConsoleStatusListener -->    <statusListener            class="ch.qos.logback.core.status.OnConsoleStatusListener"/>
    <property name="LOG_DIR" value="${catalina.base}/logs"/>
    <appender name="FILE"              class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_DIR}/access.log</file>
        <rollingPolicy                class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>access.%d{yyyy-MM-dd}.log.zip</fileNamePattern>
        </rollingPolicy>
        <encoder>
            <!-- 访问日志的格式 -->            <pattern>combined</pattern>
        </encoder>
    </appender>
    <appender-ref ref="FILE"/>
</configuration>
```

1. 官方配置：

[https://logback.qos.ch/access.html#confifiguration](https://logback.qos.ch/access.html#confifiguration)

# 7.Log4j2⭐

Apache Log4j 2是对Log4j的升级版，参考了logback的一些优秀的设计，并且修复了一些问题，因此带来了一些重大的提升，主要有：

- 异常处理，在logback中，Appender中的异常不会被应用感知到，但是在log4j2中，提供了一些异常处理机制。
- 性能提升， log4j2相较于log4j 和logback都具有很明显的性能提升，后面会有官方测试的数据。
- 自动重载配置，参考了logback的设计，当然会提供自动刷新参数配置，最实用的就是我们在生产上可以动态的修改日志的级别而不需要重启应用。
- 无垃圾机制，log4j2在大部分情况下，都可以使用其设计的一套无垃圾机制，避免频繁的日志收集导致的jvm gc。

官网： [https://logging.apache.org/log4j/2.x/](https://logging.apache.org/log4j/2.x/)

## 7.1 Log4j2入门

目前市面上最主流的日志门面就是SLF4J，虽然Log4j2也是日志门面，因为它的日志实现功能非常强大，性能优越。所以大家一般还是将Log4j2看作是日志的实现，Slf4j + Log4j2应该是未来的大势所趋。 添加依赖：

```xml
<!-- Log4j2 门面API--><dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-api</artifactId>
    <version>2.11.1</version>
</dependency>
<!-- Log4j2 日志实现 --><dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.11.1</version>
</dependency>
```

代码：

```java
@Testpublic void test1(){    // 获取日志记录器    Logger logger = LoggerFactory.getLogger(Slf4jTest.class);    // 打印    logger.error("error");    logger.warn("warn");    logger.info("info");    logger.debug("debug");    logger.trace("trace");    // 使用占位符，将程序信息输出到日志    String name = "张三";    int age = 20;    logger.info("用户信息：{}，{}",name, age);    // 将异常输出到日志    try {        int number = 1 / 0;    } catch (Exception e) {        logger.error("出现异常：",e);    }}
```

使用slf4j作为日志的门面,使用log4j2作为日志的实现：

```xml
<!-- Log4j2 门面API--><dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-api</artifactId>
    <version>2.11.1</version>
</dependency>
<!-- Log4j2 日志实现 --><dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.11.1</version>
</dependency>
<!--使用slf4j作为日志的门面,使用log4j2来记录日志 --><dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.25</version>
</dependency>
<!--为slf4j绑定日志实现 log4j2的适配器 --><dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-slf4j-impl</artifactId>
    <version>2.10.0</version>
</dependency>
```

## 7.2 Log4j2 配置

log4j2默认加载classpath下的 log4j2.xml 文件中的配置。

```xml
<?xml version="1.0" encoding="UTF-8"?><Configuration status="warn" monitorInterval="5">
    <properties>
        <property name="LOG_HOME">D:/logs</property>
    </properties>
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] [%-5level] %c{36}:%L --- %m%n" />
        </Console>
        <File name="file" fileName="${LOG_HOME}/myfile.log">
            <PatternLayout pattern="[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] %l%c{36} - %m%n" />
        </File>
        <RandomAccessFile name="accessFile" fileName="${LOG_HOME}/myAcclog.log">
            <PatternLayout pattern="[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] %l%c{36} - %m%n" />
        </RandomAccessFile>
        <RollingFile name="rollingFile" fileName="${LOG_HOME}/myrollog.log"                     filePattern="D:/logs/$${date:yyyy-MM-dd}/myrollog-%d{yyyyMM-dd-HH-mm}-%i.log">
            <ThresholdFilter level="debug" onMatch="ACCEPT" onMismatch="DENY" />
            <PatternLayout pattern="[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] %l%c{36} - %msg%n" />
            <Policies>
                <OnStartupTriggeringPolicy />
                <SizeBasedTriggeringPolicy size="10 MB" />
                <TimeBasedTriggeringPolicy />
            </Policies>
            <DefaultRolloverStrategy max="30" />
        </RollingFile>
    </Appenders>
    <Loggers>
        <Root level="trace">
            <AppenderRef ref="Console" />
        </Root>
    </Loggers>
</Configuration>
```

## 7.3 Log4j2 异步日志

log4j2最大的特点就是异步日志，其性能的提升主要也是从异步日志中受益，我们来看看如何使用log4j2的异步日志。

- 同步日志：

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671520571429-26f81373-12f9-4410-831d-4589c09b5850.png#averageHue=%23b2cb96&clientId=ua2b4bcad-d821-4&from=paste&height=353&id=ue5a0f78b&originHeight=388&originWidth=1130&originalType=binary&ratio=1&rotation=0&showTitle=false&size=205660&status=done&style=none&taskId=uf2420336-403b-4138-a3fc-67d08f8ee3d&title=&width=1027.272705007191)

image.png

- 异步日志：

Log4j2提供了两种实现日志的方式，一个是通过AsyncAppender，一个是通过AsyncLogger，分别对应前面我们说的Appender组件和Logger组件。 注意：配置异步日志需要添加依赖：

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671520585505-b0daa890-52a9-42a8-816e-afd415dab0b0.png#averageHue=%23b2d1a6&clientId=ua2b4bcad-d821-4&from=paste&height=220&id=uba566a9f&originHeight=242&originWidth=1142&originalType=binary&ratio=1&rotation=0&showTitle=false&size=145092&status=done&style=none&taskId=uc56c51d9-66be-43ee-ac9b-00ba7c8e725&title=&width=1038.1817956798338)

image.png

```xml
<!--异步日志依赖--><dependency>
    <groupId>com.lmax</groupId>
    <artifactId>disruptor</artifactId>
    <version>3.3.4</version>
</dependency>
```

1. AsyncAppender方式

```xml
<?xml version="1.0" encoding="UTF-8"?><Configuration status="warn">
    <properties>
        <property name="LOG_HOME">D:/logs</property>
    </properties>
    <Appenders>
        <File name="file" fileName="${LOG_HOME}/myfile.log">
            <PatternLayout>
                <Pattern>%d %p %c{1.} [%t] %m%n</Pattern>
            </PatternLayout>
        </File>
        <Async name="Async">
            <AppenderRef ref="file"/>
        </Async>
    </Appenders>
    <Loggers>
        <Root level="error">
            <AppenderRef ref="Async"/>
        </Root>
    </Loggers>
</Configuration
```

1. AsyncLogger方式

AsyncLogger才是log4j2 的重头戏，也是官方推荐的异步方式。它可以使得调用Logger.log返回的更快。你可以有两种选择：全局异步和混合异步。

- 全局异步就是，所有的日志都异步的记录，在配置文件上不用做任何改动，只需要添加一个log4j2.component.properties 配置；

```xml
Log4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector
```

- 混合异步就是，你可以在应用中同时使用同步日志和异步日志，这使得日志的配置方式更加灵活。

```xml
<?xml version="1.0" encoding="UTF-8"?><Configuration status="WARN">
    <properties>
        <property name="LOG_HOME">D:/logs</property>
    </properties>
    <Appenders>
        <File name="file" fileName="${LOG_HOME}/myfile.log">
            <PatternLayout>
                <Pattern>%d %p %c{1.} [%t] %m%n</Pattern>
            </PatternLayout>
        </File>
        <Async name="Async">
            <AppenderRef ref="file"/>
        </Async>
    </Appenders>
    <Loggers>
        <AsyncLogger name="com.itheima" level="trace"                     includeLocation="false" additivity="false">
            <AppenderRef ref="file"/>
        </AsyncLogger>
        <Root level="info" includeLocation="true">
            <AppenderRef ref="file"/>
        </Root>
    </Loggers>
</Configuration>
```

如上配置： com.itheima 日志是异步的，root日志是同步的。 使用异步日志需要注意的问题：

1. 如果使用异步日志，AsyncAppender、AsyncLogger和全局日志，不要同时出现。性能会和AsyncAppender一致，降至最低。
2. 设置includeLocation=false ，打印位置信息会急剧降低异步日志的性能，比同步日志还要慢。

## 7.4 Log4j2 的性能

Log4j2最牛的地方在于异步输出日志时的性能表现，Log4j2在多线程的环境下吞吐量与Log4j和Logback的比较如下图。下图比较中Log4j2有三种模式：1）全局使用异步模式；2）部分Logger采用异步模式；3）异步Appender。可以看出在前两种模式下，Log4j2的性能较之Log4j和Logback有很大的优势。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671521015640-b0cf51a4-f62e-4e67-b639-6e76e2928167.png#averageHue=%23f3f1f1&clientId=ua2b4bcad-d821-4&from=paste&height=539&id=u70b0a0f7&originHeight=593&originWidth=1135&originalType=binary&ratio=1&rotation=0&showTitle=false&size=184703&status=done&style=none&taskId=u11436848-945c-4396-a18b-f2106ca8c95&title=&width=1031.8181594541254)

image.png

无垃圾记录 垃圾收集暂停是延迟峰值的常见原因，并且对于许多系统而言，花费大量精力来控制这些暂停。许多日志库（包括以前版本的Log4j）在稳态日志记录期间分配临时对象，如日志事件对象，字符串，字符数组，字节数组等。这会对垃圾收集器造成压力并增加GC暂停发生的频率。从版本2.6开始，默认情况下Log4j以“无垃圾”模式运行，其中重用对象和缓冲区，并且尽可能不分配临时对象。还有一个“低垃圾”模式，它不是完全无垃圾，但不使用ThreadLocal字段。Log4j 2.6中的无垃圾日志记录部分通过重用ThreadLocal字段中的对象来实现，部分通过在将文本转换为字节时重用缓冲区来实现。 使用Log4j 2.5：内存分配速率809 MB /秒，141个无效集合。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671521086692-fe4e7c88-8333-4fbc-8d13-dfc757ad79e1.png#averageHue=%23e0a479&clientId=ua2b4bcad-d821-4&from=paste&height=688&id=uf4fdcd75&originHeight=757&originWidth=1156&originalType=binary&ratio=1&rotation=0&showTitle=false&size=343834&status=done&style=none&taskId=u3d0b07c0-715c-4282-888a-a666de65683&title=&width=1050.9090681312503)

image.png

Log4j 2.6没有分配临时对象：0（零）垃圾回收。

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671521104595-a2bc637e-2eb8-4734-b04f-a46016584758.png#averageHue=%23d0c3b2&clientId=ua2b4bcad-d821-4&from=paste&height=689&id=u5728d143&originHeight=758&originWidth=1148&originalType=binary&ratio=1&rotation=0&showTitle=false&size=297352&status=done&style=none&taskId=u12ad3043-d9d2-4d8d-a019-603d01859b5&title=&width=1043.636341016155)

image.png

有两个单独的系统属性可用于手动控制Log4j用于避免创建临时对象的机制：

- log4j2.enableThreadlocals - 如果“true”（非Web应用程序的默认值）对象存储在 ThreadLocal字段中并重新使用，否则将为每个日志事件创建新对象。
- log4j2.enableDirectEncoders - 如果将“true”（默认）日志事件转换为文本，则将此文本转换 为字节而不创建临时对象。注意： 由于共享缓冲区上的同步，在此模式下多线程应用程序的同步日志记录性能可能更差。如果您的应用程序是多线程的并且日志记录性能很重要，请考虑使用异步记录器。

# 8.SpringBoot中日志的使用

springboot框架在企业中的使用越来越普遍，springboot日志也是开发中常用的日志系统。springboot默认就是使用SLF4J作为日志门面，logback作为日志实现来记录日志。

## 8.1 SpringBoot中日志设计

springboot中的日志

```xml
<dependency>
    <artifactId>spring-boot-starter-logging</artifactId>
    <groupId>org.springframework.boot</groupId>
</dependency>
```

依赖关系图：

![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671521246329-f559b972-03b0-4a72-951e-2873fa62a3e3.png#averageHue=%23e7e6d7&clientId=ua2b4bcad-d821-4&from=paste&height=369&id=uaa67af1e&originHeight=406&originWidth=1174&originalType=binary&ratio=1&rotation=0&showTitle=false&size=200051&status=done&style=none&taskId=ucd7eec2b-e204-4015-bd1e-655ee39ca60&title=&width=1067.2727041402145)

image.png

总结：

1. springboot 底层默认使用logback作为日志实现。
2. 使用了SLF4J作为日志门面
3. 将JUL也转换成slf4j
4. 也可以使用log4j2作为日志门面，但是最终也是通过slf4j调用logback

## 8.2 SpringBoot中日志使用

1. 在springboot中测试打印日志

```java
@SpringBootTestclass SpringbootLogApplicationTests {    //记录器    public static final Logger LOGGER =            LoggerFactory.getLogger(SpringbootLogApplicationTests.class);    @Test    public void contextLoads() {// 打印日志信息        LOGGER.error("error");        LOGGER.warn("warn");        LOGGER.info("info"); // 默认日志级别        LOGGER.debug("debug");        LOGGER.trace("trace");    }}
```

2.修改默认日志配置

```
logging.level.com.itheima=trace
# 在控制台输出的日志的格式 同logback
logging.pattern.console=%d{yyyy-MM-dd} [%thread] [%-5level] %logger{50} - %msg%n
# 指定文件中日志输出的格式
logging.file=D:/logs/springboot.log
logging.pattern.file=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n
```

1. 指定配置 给类路径下放上每个日志框架自己的配置文件；SpringBoot就不使用默认配置的了
    
    logback.xml：直接就被日志框架识别了
    
    ![](https://cdn.nlark.com/yuque/0/2022/png/29046015/1671521448098-3222be42-2c67-4599-ba5a-252cd40548e4.png#averageHue=%23f7f7f6&clientId=ua2b4bcad-d821-4&from=paste&height=232&id=u8e392f01&originHeight=255&originWidth=1077&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42344&status=done&style=none&taskId=uaedd39b8-1111-4a0b-a28d-7183cbc0753&title=&width=979.0908878696856)
    
    image.png
    
2. 使用SpringBoot解析日志配置 logback-spring.xml：由SpringBoot解析日志配置
    

```xml
<encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
    <springProfile name="dev">
        <pattern>${pattern}</pattern>
    </springProfile>
    <springProfile name="pro">
        <pattern>%d{yyyyMMdd:HH:mm:ss.SSS} [%thread] %-5level
            %msg%n</pattern>
    </springProfile>
</encoder>
```

application.properties

```
spring.profiles.active=dev
```

1. 将日志切换为log4j2

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <!--排除logback-->        <exclusion>
            <artifactId>spring-boot-starter-logging</artifactId>
            <groupId>org.springframework.boot</groupId>
        </exclusion>
    </exclusions>
</dependency>
<!-- 添加log4j2 --><dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
```

# 9.Lombok中的日志