# 异步编程
## 异步编程概述


## 回调函数
### 基础概述



### 工作原理





### 回调示例
```js
function fetchData(callback) {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", "https://api.example.com/data");
  xhr.onload = () => {
    if (xhr.status === 200) {
      callback(null, JSON.parse(xhr.responseText));
    } else {
      callback(new Error("Request failed"));
    }
  };
  xhr.onerror = () => callback(new Error("Network error"));
  xhr.send();
}

fetchData((err, data) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log(data);
});
```




## Promise
### 基础概述
- 定义
	- Promise 是 ES6（ECMAScript 2015）引入的异步编程解决方案，用于处理异步操作的结果。
	- Promise 是一个对象，表示一个异步操作的最终完成（成功）或失败（以及原因）
	- 相比回调函数，Promise 提供了更清晰的代码结构和更好的错误处理机制。
- 核心特征
	- **状态**：Promise 有三种状态，且状态只能单向变化：
		- **Pending（待定）**：初始状态，操作尚未完成。
		- **Fulfilled（已完成）**：操作成功完成，返回结果。
		- **Rejected（已拒绝）**：操作失败，返回错误原因。
	- **不可逆性**：一旦状态变为 Fulfilled 或 Rejected，不可再次改变。
	- **链式调用**：通过 .then() 和 .catch() 支持链式操作，解决回调地狱问题。
- Promise用途
	- 处理异步操作（如网络请求、文件操作、定时器）。
	- 提供统一的异步编程模型，简化错误处理。
	- 支持并发和顺序执行复杂异步逻辑。
### 基本使用
- **创建Promise**
	- 使用 `new Promise(executor)` 创建 Promise 对象。
	- `executor` 是一个函数，接收两个参数：`resolve` 和 `reject`。
		- `resolve(value)`：将 Promise 状态变为 Fulfilled，并传递结果。
		- `reject(error)`：将 Promise 状态变为 Rejected，并传递错误原因。
	- 示例：
		```js
		const promise = new Promise((resolve, reject) => {
		  setTimeout(() => {
		    const success = true;
		    if (success) {
		      resolve("Operation successful");
		    } else {
		      reject(new Error("Operation failed"));
		    }
		  }, 1000);
		});
		```
- **处理Promise结果**
	- `.then(onFulfilled, onRejected)`：处理成功或失败的结果。
		- `onFulfilled`：当 Promise 状态为 Fulfilled 时调用。
		- `onRejected`（可选）：当 Promise 状态为 Rejected 时调用。
	- `.catch(onRejected)`：专门处理错误，捕获 Promise 链中的任何错误。
	- `.finally(onFinally)`：无论成功或失败都会执行，常用于清理资源。
	- 示例：
		```js
		promise
		  .then((result) => console.log(result)) // 输出: Operation successful
		  .catch((error) => console.error(error))
		  .finally(() => console.log("Promise settled"));
		```
- **链式调用**
	- `.then()` 返回一个新的 Promise，允许链式调用。
	- 每个 `.then()` 可以转换结果或触发新的异步操作。
	- 示例：
		```js
		new Promise((resolve) => resolve(1))
		  .then((num) => num + 1)
		  .then((num) => num * 2)
		  .then((result) => console.log(result)); // 输出: 4
		```
### 静态方法
- **Promise.resolve(value)**
	- 定义：返回一个状态为 Fulfilled 的 Promise，带有指定的值。
	- 注意：用于将非 Promise 值转为 Promise 或快速创建已解决的 Promise。
	- 示例：
		```js
		Promise.resolve("Success").then((value) => console.log(value)); // 输出: Success
		```
- **Promise.reject(error)**
	- 定义：返回一个状态为 Rejected 的 Promise，带有指定的错误。
	- 示例：
		```js
		Promise.reject(new Error("Failed")).catch((error) => console.error(error)); // 输出: Error: Failed
		```
- **Promise.all(iterable)**
	- 定义：接受一个可迭代对象（如数组）的 Promise，等待所有 Promise 都解决。
	- 注意：
		- 返回一个新的 Promise，解析为包含所有结果的数组。
		- 如果任一 Promise 被拒绝，则立即以该错误拒绝。
	- 示例：
		```js
		const p1 = Promise.resolve(1);
		const p2 = Promise.resolve(2);
		const p3 = Promise.resolve(3);
		Promise.all([p1, p2, p3]).then((results) => console.log(results)); // 输出: [1, 2, 3]
		```
- **Promise.race(iterable)**
	- 定义：接受一组 Promise，返回最先解决或拒绝的 Promise 的结果。
	- 示例：
		```js
		const p1 = new Promise((resolve) => setTimeout(resolve, 100, "Fast"));
		const p2 = new Promise((resolve) => setTimeout(resolve, 200, "Slow"));
		Promise.race([p1, p2]).then((result) => console.log(result)); // 输出: Fast
		```
- **Promise.any(iterable)（ES2021）**
	- 定义：返回第一个成功的 Promise 结果。
	- 注意：
		- 只有当所有 Promise 都拒绝时，才以 AggregateError 拒绝。
		- 常用于多源数据获取的场景。
	- 示例：
		```js
		const p1 = Promise.reject(new Error("Error 1"));
		const p2 = Promise.resolve("Success");
		Promise.any([p1, p2]).then((result) => console.log(result)); // 输出: Success
		```
- **Promise.allSettled(iterable)（ES2020）**
	- 定义：等待所有 Promise 完成（无论成功或失败），返回每个 Promise 的状态和结果/错误。
	- 注意：
		- 结果为数组，每个元素为 `{ status: "fulfilled" | "rejected", value | reason }`。
	- 示例：
		```js
		const p1 = Promise.resolve(1);
		const p2 = Promise.reject(new Error("Failed"));
		Promise.allSettled([p1, p2]).then((results) => console.log(results));
		// 输出: [
		//   { status: "fulfilled", value: 1 },
		//   { status: "rejected", reason: Error: Failed }
		// ]
		```
### 错误处理
- **错误传播**
	- Promise 链中的错误会向下传递，直到被 `.catch()` 捕获。
	- 未处理的错误会导致“未捕获的 Promise 拒绝”警告。
	- 示例：
		```js
		new Promise((_, reject) => reject(new Error("Error")))
		  .then(() => console.log("Won't execute"))
		  .catch((error) => console.error(error.message)); // 输出: Error
		```
- **统一错误处理**
	- 在链的末尾使用 `.catch()` 捕获所有错误。
	- 示例：
		```js
		new Promise((resolve) => resolve(1))
		  .then(() => {
		    throw new Error("Something went wrong");
		  })
		  .then(() => console.log("Won't execute"))
		  .catch((error) => console.error(error.message)); // 输出: Something went wrong
		```
- **异步错误与同步错误**
	- Promise 内部的同步错误会被自动捕获并转为 Rejected 状态。
	- 示例：
		```js
		new Promise(() => {
		  throw new Error("Sync error");
		}).catch((error) => console.error(error.message)); // 输出: Sync error
		```
### 应用场景


### 高级用法






## Async/Await
### 基础概述



### Async 函数
- **声明 async 函数**
	- 定义：使用 `async` 关键字声明异步函数。
	- 注意：
		- Async 函数始终返回一个 Promise 对象：
			- 如果返回值是非 Promise，则自动包装为已解决的 Promise。
			- 如果抛出错误，Promise 会被拒绝。
	- 示例：
		```js
		async function example() {
		  return "Hello";
		}
		example().then((value) => console.log(value)); // 输出: Hello
		```
- **返回值处理**
	- 返回值类型：
		- 同步返回值：自动转为 `Promise.resolve(value)`。
		- Promise 返回值：直接返回该 Promise。
		- 抛出错误：转为 `Promise.reject(error)`。
	- 示例：
		```js
		async function success() {
		  return 42; // 自动转为 Promise.resolve(42)
		}
		async function error() {
		  throw new Error("Failed"); // 转为 Promise.reject(Error)
		}
		success().then((value) => console.log(value)); // 输出: 42
		error().catch((error) => console.error(error.message)); // 输出: Failed
		```
- **async 函数执行**
	- Async 函数内部的代码按顺序执行，但不阻塞主线程。
	- Await 表达式暂停函数执行，等待 Promise 解决后继续。
### Await 关键字
- **基本用法**
	- 定义：暂停执行直到 Promise 解决，返回 Promise 的结果（或抛出错误）。
	- 注意：**Await** 只能在 `async` 函数内部使用。
	- 示例：
		```js
		async function fetchData() {
		  const response = await fetch("https://api.example.com/data");
		  const data = await response.json();
		  return data;
		}
		fetchData().then((data) => console.log(data));
		```
- **Await限制**
	- 不能在普通函数中使用 `await`，否则会抛出语法错误。
	- 示例（错误用法）：
		```js
		function normalFunction() {
		  await Promise.resolve(1); // SyntaxError: await is only valid in async function
		}
		```
- **Await和Promise**
	- Await 解包 Promise 的值，简化 `.then()` 的链式调用。
	- 示例（Promise vs Async/Await）：
		```js
		// 使用 Promise
		fetch("https://api.example.com/data")
		  .then((response) => response.json())
		  .then((data) => console.log(data));
		
		// 使用 Async/Await
		async function getData() {
		  const response = await fetch("https://api.example.com/data");
		  const data = await response.json();
		  console.log(data);
		}
		```
### 错误处理
- **使用 Try-Catch**
	- 定义：Async/Await 使用 try-catch 捕获异步和同步错误，类似同步代码的错误处理。
	- 示例：
		```js
		async function fetchData() {
		  try {
		    const response = await fetch("https://api.example.com/data");
		    if (!response.ok) throw new Error("Network response was not ok");
		    const data = await response.json();
		    return data;
		  } catch (error) {
		    console.error("Error:", error.message);
		  }
		}
		fetchData();
		```
- **错误传播**
	- 未捕获的错误会使 async 函数返回一个 Rejected 的 Promise。
	- 示例：
		```js
		async function errorExample() {
		  throw new Error("Something went wrong");
		}
		errorExample().catch((error) => console.error(error.message)); // 输出: Something went wrong
		```
- **结合 Promise 的 .catch()**
	- 可以将 try-catch 与 Promise 的 .catch() 结合使用。
	- 示例：
		```js
		async function fetchData() {
		  const response = await fetch("https://api.example.com/data");
		  return response.json();
		}
		fetchData()
		  .then((data) => console.log(data))
		  .catch((error) => console.error("Error:", error));
		```
### 应用场景



### 高级用法








## 事件循环
### 基础概述



### 工作原理
- **执行流程**
	1. **执行同步代码**：
		- 主线程执行调用栈中的同步代码。
		- 遇到异步操作（如 `setTimeout`、`fetch`），将其委托给 Web APIs 处理。
	2. **Web APIs 处理异步任务**：
		- 异步任务在 Web APIs 中运行（如定时器计时、网络请求）。
		- 完成后，将回调函数推入任务队列或微任务队列。
	3. **事件循环检查**：
		- 事件循环持续监控调用栈是否为空。
		- 若调用栈为空，优先处理微任务队列中的所有任务。
		- 然后从任务队列中取一个宏任务推入调用栈执行。
	4. **重复循环**：
		- 重复上述步骤，直到所有任务处理完毕。
- **宏任务与微任务**
	- **宏任务（Macrotask）**：
		- 包括 `setTimeout`、`setInterval`、I/O 操作、UI 渲染、DOM 事件回调等。
		- 每次事件循环只处理一个宏任务。
	- **微任务（Microtask）**：
		- 包括 Promise 回调（`.then`、`.catch`、`.finally`）、`process.nextTick`（Node.js）、`MutationObserver` 等。
		- 微任务在当前宏任务完成后、下一个宏任务开始前全部执行。
	- **优先级**：微任务 > 宏任务。
- **执行顺序**
	- 示例：
		```js
		console.log("Start");
		
		setTimeout(() => console.log("Timeout"), 0);
		
		Promise.resolve().then(() => console.log("Promise"));
		
		console.log("End");
		
		// 输出顺序:
		// Start
		// End
		// Promise
		// Timeout
		```
	- 解析：
		1. `console.log("Start")`：同步代码，立即执行。
		2. `setTimeout`：注册宏任务，回调进入任务队列。
		3. `Promise.resolve().then`：注册微任务，回调进入微任务队列。
		4. `console.log("End")`：同步代码，立即执行。
		5. 调用栈清空，事件循环处理微任务队列，输出 "Promise"。
		6. 微任务队列清空，事件循环处理任务队列，输出 "Timeout"。



### 深入解析









